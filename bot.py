import os
import re
import random
import asyncio
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple

from unidecode import unidecode
from telegram import Update
from telegram.constants import ParseMode
from telegram.ext import (
    Application, ApplicationBuilder, CommandHandler,
    MessageHandler, ContextTypes, filters
)

# ============ C·∫§U H√åNH ============
ROUND_SECONDS = int(os.getenv("ROUND_SECONDS", "60"))
HALFTIME_SECONDS = int(os.getenv("HALFTIME_SECONDS", str(ROUND_SECONDS // 2)))
AUTO_BEGIN_SECONDS = int(os.getenv("AUTO_BEGIN_SECONDS", "60"))
DICT_FILE = os.getenv("DICT_FILE", "dict_vi.txt").strip()
SLANG_FILE = os.getenv("SLANG_FILE", "slang_vi.txt").strip()

ALLOW_GENZ = os.getenv("ALLOW_GENZ", "1") == "1"   # b·∫≠t/t·∫Øt c∆° ch·∫ø genZ linh ho·∫°t
GENZ_FREQ = float(os.getenv("GENZ_FREQ", "2.2"))   # ng∆∞·ª°ng wordfreq (0-7)

HALF_WARNINGS = [
    "C√≤n 30 gi√¢y cu·ªëi ƒë·ªÉ b·∫°n suy nghƒ© v·ªÅ cu·ªôc ƒë·ªùi:))",
    "T·∫Øc ·∫ª ƒë·∫øn v·∫≠y sao, 30 gi√¢y cu·ªëi n√® :||",
    "30 v·∫´n ch∆∞a ph·∫£i T·∫øt, nh∆∞ng mi s·∫Øp h·∫øt gi·ªù r·ªìi. 30 gi√¢y!",
    "M·∫Øc ƒëitt r·∫∑n m√£i kh√¥ng ra. 30 gi√¢y cu·ªëi ·∫ª!",
    "30 gi√¢y cu·ªëi n√≠ ∆°i!"
]
WRONG_ANSWERS = [
    "IQ b·∫°n c·∫ßn ph·∫£i xem x√©t l·∫°i, m·ªùi ti·∫øp !!",
    "M·ªói th·∫ø c≈©ng sai, GG c≈©ng kh√¥ng c·ª©u ƒë∆∞·ª£c !",
    "Sai r·ªìi m√°, tra l·∫°i t·ª´ ƒëi·ªÉn ƒëi !",
    "T·ª´ g√¨ v·∫≠y m√°, h·ªçc l·∫°i l·ªõp 1 ƒëi !!",
    "·∫¢o ti·∫øng Vi·ªát hee",
    "Lo·∫°i, ng∆∞·ªùi ti·∫øp theo!",
    "Ch∆∞a ti·∫øn ho√° h·∫øt √†, t·ª´ n√†y con ng∆∞·ªùi d√πng sao‚Ä¶ Sai b√©t!!"
]
TIMEOUT_MSG = "‚è∞ H·∫øt gi·ªù, m·ªùi b·∫°n ra ngo√†i ch·ªù !!"

SOLO_HINTS = [
    "T·ª´ n√†y c√≥ nghƒ©a th·∫≠t kh√¥ng ? Anh nh·∫Øc c∆∞ng",
    "Cho b√© c∆° h·ªôi n·ªØa ,",
    "C∆° h·ªôi cu·ªëi ! N·∫øu sai chu·∫©n b·ªã xu·ªëng h√†ng gh·∫ø ƒë·ªông v·∫≠t ng·ªìi !!!",
]

# ============ N·∫†P T·ª™ ƒêI·ªÇN ============
def _load_dict_file(fname: str) -> Set[str]:
    s: Set[str] = set()
    for p in [Path(fname), Path(__file__).parent / fname, Path("/opt/render/project/src") / fname]:
        if p.exists():
            with p.open("r", encoding="utf-8") as f:
                for line in f:
                    t = " ".join(line.strip().lower().split())
                    if not t:
                        continue
                    parts = t.split()
                    if len(parts) == 2 and all(part.isalpha() for part in parts):
                        s.add(t)
            break
    return s

DICT: Set[str] = _load_dict_file(DICT_FILE)
SLANG: Set[str] = _load_dict_file(SLANG_FILE)
print(f"[DICT] Chu·∫©n: {len(DICT)} | SLANG: {len(SLANG)}")

# (Tu·ª≥ ch·ªçn) wordfreq + symspell
try:
    from wordfreq import zipf_frequency
except Exception:
    zipf_frequency = None

try:
    from symspellpy import SymSpell, Verbosity
    _sym = SymSpell(max_dictionary_edit_distance=2, prefix_length=7)
    _WORDS = set()
    for p in (DICT | SLANG):
        w1, w2 = p.split()
        _WORDS.add(w1); _WORDS.add(w2)
    for w in _WORDS:
        _sym.create_dictionary_entry(w, 1)
except Exception:
    _sym = None

# ============ KI·ªÇM TRA √ÇM TI·∫æT & NGHƒ®A ============
def norm2(text: str) -> str:
    return " ".join(text.strip().lower().split())

# Heuristic ki·ªÉm tra √¢m ti·∫øt h·ª£p l·ªá (x·∫•p x·ªâ)
_VALID_ONSET = r"(ngh|gh|ng|nh|ch|th|tr|ph|qu|gi|kh|quy|b|c|d|ƒë|g|h|k|l|m|n|p|q|r|s|t|v|x)?"
# Nucleus: ƒë∆°n gi·∫£n ho√°; ƒë·ªß d√πng cho game
_VALID_NUCLEUS = r"(a|e|i|o|u|y|ai|ao|au|ay|eo|ia|iu|oa|oe|oi|ua|ui|uy|uoi|uya|uya|ye|ya|yo|yu|uu|uo|uou)"
_VALID_CODA = r"(c|ch|m|n|ng|nh|p|t)?"
_SYL_RE = re.compile(rf"^{_VALID_ONSET}{_VALID_NUCLEUS}{_VALID_CODA}$")

def _strip_diacritics(s: str) -> str:
    return unidecode(s.lower().strip())

def is_valid_syllable_vi(syllable: str) -> bool:
    s = _strip_diacritics(syllable)
    if not s.isalpha():
        return False
    return bool(_SYL_RE.match(s))

def is_two_word_form(text: str) -> Tuple[bool, List[str]]:
    t = norm2(text)
    parts = t.split()
    if len(parts) != 2:
        return False, parts
    if not all(p.isalpha() for p in parts):
        return False, parts
    if not all(is_valid_syllable_vi(p) for p in parts):
        return False, parts
    return True, parts

def _freq_ok(w: str) -> bool:
    if not zipf_frequency:
        return False
    return zipf_frequency(w, "vi") >= GENZ_FREQ

def is_meaningful(text: str) -> Tuple[bool, str, Dict]:
    """
    Tr·∫£ v·ªÅ (ok, normalized_text, info)
      - ∆Øu ti√™n DICT -> SLANG
      - N·∫øu ALLOW_GENZ & c√≥ wordfreq: ch·∫•p nh·∫≠n n·∫øu c·∫£ 2 t·ª´ >= GENZ_FREQ
      - N·∫øu c√≥ symspell: autocorrect t·ª´ng t·ª´ r·ªìi th·ª≠ l·∫°i
    """
    t = norm2(text)
    form_ok, parts = is_two_word_form(t)
    info = {"source": None, "w1": None, "w2": None, "note": None}
    if not form_ok:
        info["note"] = "form_invalid"
        return False, t, info

    w1, w2 = parts
    info["w1"], info["w2"] = w1, w2

    if t in DICT:
        info["source"] = "DICT"
        return True, t, info
    if ALLOW_GENZ and t in SLANG:
        info["source"] = "SLANG"
        return True, t, info

    if ALLOW_GENZ and _freq_ok(w1) and _freq_ok(w2):
        info["source"] = "FREQ"
        return True, t, info

    if _sym:
        sug1 = _sym.lookup(w1, Verbosity.CLOSEST, max_edit_distance=1)
        sug2 = _sym.lookup(w2, Verbosity.CLOSEST, max_edit_distance=1)
        c1 = sug1[0].term if sug1 else w1
        c2 = sug2[0].term if sug2 else w2
        cand = f"{c1} {c2}"
        if cand in DICT or (ALLOW_GENZ and cand in SLANG):
            info["source"] = "CORRECTED"
            return True, cand, info
        if ALLOW_GENZ and _freq_ok(c1) and _freq_ok(c2):
            info["source"] = "CORRECTED+FREQ"
            return True, cand, info

    info["note"] = "not_in_dict"
    return False, t, info

# ============ RHYME (ƒê·ªêI V·∫¶N) ============
ONSET_CLUSTERS = ["ngh","gh","ng","nh","ch","th","tr","ph","qu","gi","kh","quy"]
CONSONANTS = set(list("bcdfghjklmnpqrstvxƒë"))

def rhyme_key(syllable: str) -> str:
    syl = unidecode(syllable.lower().strip())
    for cl in ONSET_CLUSTERS:
        if syl.startswith(cl):
            base = syl[len(cl):]
            return base or syl
    if syl and syl[0] in CONSONANTS:
        syl = syl[1:]
    return syl or syllable

def split_phrase(phrase: str) -> Tuple[str, str]:
    parts = norm2(phrase).split()
    if len(parts) != 2:
        return "", ""
    return parts[0], parts[1]

def rhyme_match(prev_phrase: Optional[str], next_phrase: str) -> bool:
    if not prev_phrase:
        return True
    p1, p2 = split_phrase(prev_phrase)
    n1, _ = split_phrase(next_phrase)
    if not (p2 and n1):
        return False
    return rhyme_key(p2) == rhyme_key(n1)

# ============ GAME STATE ============
@dataclass
class Match:
    chat_id: int
    lobby_open: bool = False
    joined: List[int] = field(default_factory=list)
    active: bool = False
    turn_idx: int = 0
    current_player: Optional[int] = None
    current_phrase: Optional[str] = None

    auto_begin_task: Optional[asyncio.Task] = None
    half_task: Optional[asyncio.Task] = None
    timeout_task: Optional[asyncio.Task] = None

    used_phrases: Set[str] = field(default_factory=set)

    solo_mode: bool = False
    solo_warn_count: int = 0

    def cancel_turn_tasks(self):
        for t in (self.half_task, self.timeout_task):
            if t and not t.done():
                t.cancel()
        self.half_task = None
        self.timeout_task = None

    def cancel_auto_begin(self):
        if self.auto_begin_task and not self.auto_begin_task.done():
            self.auto_begin_task.cancel()
        self.auto_begin_task = None

matches: Dict[int, Match] = {}

# ============ TI·ªÜN √çCH ============
async def mention_user(context: ContextTypes.DEFAULT_TYPE, chat_id: int, user_id: int) -> str:
    try:
        member = await context.bot.get_chat_member(chat_id, user_id)
        name = member.user.first_name or ""
        return f"[{name}](tg://user?id={user_id})"
    except Exception:
        return f"user_{user_id}"

def pick_next_idx(match: Match):
    if not match.joined:
        return
    match.turn_idx %= len(match.joined)
    match.current_player = match.joined[match.turn_idx]

def random_bot_phrase(match: Match) -> Optional[str]:
    if not match.current_phrase:
        candidates = list((DICT | SLANG) - match.used_phrases)
        return random.choice(candidates) if candidates else None
    _, prev_last = split_phrase(match.current_phrase)
    need_key = rhyme_key(prev_last)
    pool = (DICT | SLANG) - match.used_phrases
    candidates = [p for p in pool if rhyme_key(split_phrase(p)[0]) == need_key]
    return random.choice(candidates) if candidates else None

async def schedule_turn_timers(update: Update, context: ContextTypes.DEFAULT_TYPE, match: Match):
    match.cancel_turn_tasks()

    async def half_warn():
        try:
            await asyncio.sleep(HALFTIME_SECONDS)
            if match.active:
                who = await mention_user(context, match.chat_id, match.current_player)
                msg = random.choice(HALF_WARNINGS)
                await context.bot.send_message(
                    match.chat_id, f"‚è≥ {who} ‚Äî {msg}", parse_mode=ParseMode.MARKDOWN
                )
        except asyncio.CancelledError:
            pass

    async def timeout_kick():
        try:
            await asyncio.sleep(ROUND_SECONDS)
            if not match.active:
                return
            who = match.current_player
            who_m = await mention_user(context, match.chat_id, who)
            await context.bot.send_message(match.chat_id, f"‚ùå {who_m} ‚Äî {TIMEOUT_MSG}", parse_mode=ParseMode.MARKDOWN)

            if match.solo_mode:
                match.active = False
                match.cancel_turn_tasks()
                await context.bot.send_message(match.chat_id, "üèÅ V√°n solo k·∫øt th√∫c. Bot th·∫Øng ü§ñ")
                return

            if who in match.joined:
                idx = match.joined.index(who)
                match.joined.pop(idx)
                if idx <= match.turn_idx and match.turn_idx > 0:
                    match.turn_idx -= 1

            if len(match.joined) <= 1:
                if match.joined:
                    winner = await mention_user(context, match.chat_id, match.joined[0])
                    await context.bot.send_message(match.chat_id, f"üèÜ {winner} th·∫Øng cu·ªôc!", parse_mode=ParseMode.MARKDOWN)
                match.active = False
                match.cancel_turn_tasks()
                return

            match.turn_idx = (match.turn_idx + 1) % len(match.joined)
            pick_next_idx(match)
            who2 = await mention_user(context, match.chat_id, match.current_player)
            await context.bot.send_message(
                match.chat_id,
                f"üü¢ {who2} ƒë·∫øn l∆∞·ª£t. G·ª≠i **c·ª•m 2 t·ª´** ƒë√∫ng v·∫ßn v·ªõi c·ª•m tr∆∞·ªõc.",
                parse_mode=ParseMode.MARKDOWN,
            )
            await schedule_turn_timers(update, context, match)
        except asyncio.CancelledError:
            pass

    # ch·ªâ ƒë·∫∑t timer cho l∆∞·ª£t ng∆∞·ªùi ch∆°i
    if not match.solo_mode or (match.solo_mode and match.current_player is not None):
        loop = asyncio.get_running_loop()
        match.half_task = loop.create_task(half_warn())
        match.timeout_task = loop.create_task(timeout_kick())

# ============ HANDLERS ============
async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "Ch√†o c·∫£ nh√†! /newgame ƒë·ªÉ m·ªü s·∫£nh, /join ƒë·ªÉ tham gia.\n"
        f"ƒê·ªß 2 ng∆∞·ªùi, bot ƒë·∫øm ng∆∞·ª£c {AUTO_BEGIN_SECONDS}s r·ªìi t·ª± b·∫Øt ƒë·∫ßu.\n"
        "Lu·∫≠t: ƒë√∫ng 2 t·ª´, c√≥ nghƒ©a (DICT/SLANG ho·∫∑c linh ho·∫°t), v√† **ƒë·ªëi v·∫ßn**: t·ª´ 1 c·ªßa c·ª•m m·ªõi c√πng v·∫ßn v·ªõi t·ª´ 2 c·ªßa c·ª•m tr∆∞·ªõc.\n"
        f"T·ª´ ƒëi·ªÉn: {len(DICT)} chu·∫©n + {len(SLANG)} slang."
    )

async def cmd_reload(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global DICT, SLANG
    DICT = _load_dict_file(DICT_FILE)
    SLANG = _load_dict_file(SLANG_FILE)
    await update.message.reply_text(f"üîÅ N·∫°p l·∫°i: DICT={len(DICT)} | SLANG={len(SLANG)}")

async def cmd_ping(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("pong ‚úÖ")

async def cmd_check(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.args:
        await update.message.reply_text("D√πng: /check <c·ª•m 2 t·ª´>")
        return
    phrase = " ".join(context.args)
    form_ok, _ = is_two_word_form(phrase)
    ok, norm, info = is_meaningful(phrase)
    lines = []
    lines.append(f"üß™ `{phrase}` ‚Üí `{norm}`")
    lines.append(f"‚Ä¢ √Çm ti·∫øt h·ª£p l·ªá: {'‚úÖ' if form_ok else '‚ùå'}")
    lines.append(f"‚Ä¢ C√≥ nghƒ©a: {'‚úÖ' if ok else '‚ùå'}")
    src = info.get("source")
    if ok:
        lines.append(f"  ‚Ü≥ Ngu·ªìn: {src or 'UNKNOWN'}")
    else:
        note = info.get("note")
        if note == "form_invalid":
            lines.append("  ‚Ü≥ L√Ω do: gh√©p √¢m b·∫•t h·ª£p ph√°p / kh√¥ng ƒë√∫ng 2 t·ª´.")
        elif note == "not_in_dict":
            lines.append("  ‚Ü≥ Kh√¥ng th·∫•y trong DICT/SLANG v√† kh√¥ng qua ng∆∞·ª°ng t·∫ßn su·∫•t.")
    await update.message.reply_text("\n".join(lines), parse_mode=ParseMode.MARKDOWN)

async def cmd_newgame(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    m = matches.get(chat_id) or Match(chat_id)
    m.lobby_open = True
    m.joined = []
    m.active = False
    m.turn_idx = 0
    m.current_player = None
    m.current_phrase = None
    m.used_phrases.clear()
    m.solo_mode = False
    m.solo_warn_count = 0
    m.cancel_turn_tasks()
    m.cancel_auto_begin()
    matches[chat_id] = m
    await update.message.reply_text(
        f"üéÆ S·∫£nh m·ªü! /join ƒë·ªÉ tham gia.\n"
        f"‚û°Ô∏è Khi **ƒë·ªß 2 ng∆∞·ªùi**, bot s·∫Ω ƒë·∫øm ng∆∞·ª£c {AUTO_BEGIN_SECONDS}s r·ªìi t·ª± b·∫Øt ƒë·∫ßu."
    )

async def cmd_join(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    user_id = update.effective_user.id
    m = matches.get(chat_id)
    if not m or not m.lobby_open:
        await update.message.reply_text("Ch∆∞a /newgame m√† nh·∫≠p l·ªë n√® üòõ")
        return
    if user_id in m.joined:
        await update.message.reply_text("B·∫°n ƒë√£ tham gia!")
        return
    m.joined.append(user_id)
    who = await mention_user(context, chat_id, user_id)
    await update.message.reply_text(f"‚ûï {who} ƒë√£ tham gia!", parse_mode=ParseMode.MARKDOWN)

    # V·ª´a ƒë·ªß 2 ng∆∞·ªùi ‚Üí b·∫Øt ƒë·∫ßu ƒë·∫øm ng∆∞·ª£c
    if len(m.joined) == 2 and m.auto_begin_task is None:
        async def auto_begin():
            try:
                await asyncio.sleep(AUTO_BEGIN_SECONDS)
                if m.lobby_open and not m.active and len(m.joined) >= 2:
                    await force_begin(update, context, m)
            except asyncio.CancelledError:
                pass
        loop = asyncio.get_running_loop()
        m.auto_begin_task = loop.create_task(auto_begin())
        await context.bot.send_message(chat_id, f"‚è≥ ƒê·ªß 2 ng∆∞·ªùi r·ªìi. {AUTO_BEGIN_SECONDS}s n·ªØa b·∫Øt ƒë·∫ßu t·ª± ƒë·ªông!")

async def cmd_begin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    m = matches.get(chat_id)
    if not m:
        await update.message.reply_text("Ch∆∞a /newgame k√¨a.")
        return
    await force_begin(update, context, m)

async def force_begin(update: Update, context: ContextTypes.DEFAULT_TYPE, m: Match):
    if m.active:
        return
    m.lobby_open = False
    m.cancel_auto_begin()

    if len(m.joined) == 0:
        await context.bot.send_message(m.chat_id, "Kh√¥ng c√≥ ai tham gia n√™n hu·ª∑ v√°n.")
        return

    if len(m.joined) == 1:
        # SOLO
        m.solo_mode = True
        m.solo_warn_count = 0
        m.active = True
        m.turn_idx = 0
        m.current_player = m.joined[0]
        m.current_phrase = None
        await context.bot.send_message(
            m.chat_id,
            "ü§ñ Ch·ªâ c√≥ 1 ng∆∞·ªùi tham gia ‚Üí SOLO v·ªõi bot.\n"
            "üìò Lu·∫≠t: ƒë√∫ng 2 t·ª´ ‚Ä¢ c√≥ nghƒ©a (t·ª•c/GenZ linh ho·∫°t) ‚Ä¢ **ƒë·ªëi v·∫ßn** (t·ª´ 1 = v·∫ßn t·ª´ 2 c·ª•m tr∆∞·ªõc)."
        )
        who = await mention_user(context, m.chat_id, m.current_player)
        await context.bot.send_message(
            m.chat_id, f"üëâ {who} ƒëi tr∆∞·ªõc. L∆∞·ª£t ƒë·∫ßu t·ª± do.", parse_mode=ParseMode.MARKDOWN
        )
        await schedule_turn_timers(update, context, m)
        return

    # MULTI
    m.solo_mode = False
    m.active = True
    random.shuffle(m.joined)
    m.turn_idx = random.randrange(len(m.joined))
    m.current_player = m.joined[m.turn_idx]
    m.current_phrase = None
    await context.bot.send_message(
        m.chat_id,
        "üöÄ B·∫Øt ƒë·∫ßu (multiplayer)! Sai lu·∫≠t ho·∫∑c h·∫øt gi·ªù s·∫Ω b·ªã lo·∫°i.\n"
        "üìò Lu·∫≠t: ƒë√∫ng 2 t·ª´ ‚Ä¢ c√≥ nghƒ©a (DICT/SLANG/linh ho·∫°t) ‚Ä¢ **ƒë·ªëi v·∫ßn**."
    )
    who = await mention_user(context, m.chat_id, m.current_player)
    await context.bot.send_message(
        m.chat_id, f"üëâ {who} ƒëi tr∆∞·ªõc. L∆∞·ª£t ƒë·∫ßu t·ª± do.", parse_mode=ParseMode.MARKDOWN
    )
    await schedule_turn_timers(update, context, m)

async def cmd_stop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    m = matches.get(chat_id)
    if not m:
        await update.message.reply_text("Kh√¥ng c√≥ v√°n n√†o.")
        return
    m.lobby_open = False
    m.active = False
    m.cancel_turn_tasks()
    m.cancel_auto_begin()
    await update.message.reply_text("‚õî ƒê√£ d·ª´ng v√°n hi·ªán t·∫°i.")

# ============ NH·∫¨N C√ÇU TR·∫¢ L·ªúI ============
async def on_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.message.text:
        return
    chat_id = update.effective_chat.id
    user_id = update.effective_user.id
    raw = update.message.text
    m = matches.get(chat_id)
    if not m or not m.active:
        return
    if user_id != m.current_player:
        return

    # 1) Ki·ªÉu 2 t·ª´ + √¢m ti·∫øt h·ª£p l·ªá
    form_ok, _ = is_two_word_form(raw)
    # 2) Nghƒ©a (lai)
    meaning_ok, normalized, info = is_meaningful(raw)
    # 3) Ch∆∞a d√πng
    not_used = normalized not in m.used_phrases
    # 4) ƒê·ªëi v·∫ßn
    rhyme_ok = rhyme_match(m.current_phrase, normalized)

    valid = form_ok and meaning_ok and not_used and rhyme_ok

    if not valid:
        if m.solo_mode:
            if m.solo_warn_count < 3:
                hint = SOLO_HINTS[m.solo_warn_count] if m.solo_warn_count < len(SOLO_HINTS) else SOLO_HINTS[-1]
                m.solo_warn_count += 1
                # G·ª£i √Ω ng·∫Øn l√Ω do
                reasons = []
                if not form_ok: reasons.append("gh√©p √¢m/kh√¥ng ƒë√∫ng 2 t·ª´")
                if not meaning_ok: reasons.append("kh√¥ng th·∫•y nghƒ©a h·ª£p l·ªá")
                if not not_used: reasons.append("ƒë√£ d√πng r·ªìi")
                if not rhyme_ok: reasons.append("sai ƒë·ªëi v·∫ßn")
                extra = f" ({', '.join(reasons)})" if reasons else ""
                await update.message.reply_text(f"‚ö†Ô∏è {hint}{extra}")
                return
            else:
                await update.message.reply_text("‚ùå Sai li√™n ti·∫øp. Bot th·∫Øng ü§ñ")
                m.active = False
                m.cancel_turn_tasks()
                return
        else:
            msg = random.choice(WRONG_ANSWERS)
            await update.message.reply_text(f"‚ùå {msg}")
            idx = m.joined.index(user_id)
            m.joined.pop(idx)
            if idx <= m.turn_idx and m.turn_idx > 0:
                m.turn_idx -= 1
            if len(m.joined) <= 1:
                if m.joined:
                    winner = await mention_user(context, chat_id, m.joined[0])
                    await context.bot.send_message(chat_id, f"üèÜ {winner} th·∫Øng cu·ªôc!", parse_mode=ParseMode.MARKDOWN)
                m.active = False
                m.cancel_turn_tasks()
                return
            m.turn_idx = (m.turn_idx + 1) % len(m.joined)
            m.current_player = m.joined[m.turn_idx]
            who2 = await mention_user(context, chat_id, m.current_player)
            await context.bot.send_message(
                chat_id, f"üü¢ {who2} ƒë·∫øn l∆∞·ª£t. G·ª≠i **c·ª•m 2 t·ª´** ƒë√∫ng v·∫ßn v·ªõi c·ª•m tr∆∞·ªõc.",
                parse_mode=ParseMode.MARKDOWN
            )
            await schedule_turn_timers(update, context, m)
            return

    # ===== H·ª¢P L·ªÜ =====
    text = normalized
    m.used_phrases.add(text)
    m.current_phrase = text

    if m.solo_mode:
        m.solo_warn_count = 0
        await update.message.reply_text(f"‚úÖ H·ª£p l·ªá ({info.get('source') or 'OK'}). T·ªõi l∆∞·ª£t bot ü§ñ")
        m.cancel_turn_tasks()

        bot_pick = random_bot_phrase(m)
        if not bot_pick or not rhyme_match(m.current_phrase, bot_pick):
            await context.bot.send_message(chat_id, "ü§ñ H·∫øt ch·ªØ h·ª£p v·∫ßn‚Ä¶ B·∫°n th·∫Øng! üèÜ")
            m.active = False
            return

        m.used_phrases.add(bot_pick)
        m.current_phrase = bot_pick
        await context.bot.send_message(chat_id, f"ü§ñ Bot: **{bot_pick}**", parse_mode=ParseMode.MARKDOWN)

        await context.bot.send_message(chat_id, "üëâ T·ªõi l∆∞·ª£t b·∫°n. G·ª≠i **c·ª•m 2 t·ª´** ƒë√∫ng v·∫ßn.")
        await schedule_turn_timers(update, context, m)
        return

    await update.message.reply_text(f"‚úÖ H·ª£p l·ªá ({info.get('source') or 'OK'}). T·ªõi l∆∞·ª£t k·∫ø ti·∫øp!")
    m.turn_idx = (m.turn_idx + 1) % len(m.joined)
    m.current_player = m.joined[m.turn_idx]
    who2 = await mention_user(context, chat_id, m.current_player)
    await context.bot.send_message(
        chat_id, f"üü¢ {who2} ƒë·∫øn l∆∞·ª£t. G·ª≠i **c·ª•m 2 t·ª´** ƒë√∫ng v·∫ßn v·ªõi c·ª•m tr∆∞·ªõc.",
        parse_mode=ParseMode.MARKDOWN
    )
    await schedule_turn_timers(update, context, m)

# ============ APP ============
def build_app() -> Application:
    token = os.getenv("TELEGRAM_TOKEN", "").strip()
    if not token:
        raise RuntimeError("Missing TELEGRAM_TOKEN")
    app = ApplicationBuilder().token(token).build()
    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CommandHandler("ping", cmd_ping))
    app.add_handler(CommandHandler("reload", cmd_reload))
    app.add_handler(CommandHandler("check", cmd_check))
    app.add_handler(CommandHandler("newgame", cmd_newgame))
    app.add_handler(CommandHandler("join", cmd_join))
    app.add_handler(CommandHandler("begin", cmd_begin))
    app.add_handler(CommandHandler("stop", cmd_stop))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, on_text))
    return app
