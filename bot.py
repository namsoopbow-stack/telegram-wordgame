# bot.py ‚Äî Multi-Game (ƒê·ªëi Ch·ªØ + ƒêo√°n Ch·ªØ)
import os, re, json, random, time, logging
from collections import deque
from typing import Dict, List, Set, Optional, Tuple

import requests
from bs4 import BeautifulSoup
from unidecode import unidecode

from telegram import (
    Update, InlineKeyboardMarkup, InlineKeyboardButton
)
from telegram.constants import ParseMode, ChatType
from telegram.ext import (
    Application, ApplicationBuilder, AIORateLimiter,
    CommandHandler, MessageHandler, CallbackQueryHandler,
    ContextTypes, filters
)

logging.basicConfig(level=logging.INFO)
log = logging.getLogger("multigame")

# ================== ENV & CONST ==================
BOT_TOKEN = os.getenv("TELEGRAM_TOKEN", "").strip()

# Lobby chung (cho c·∫£ 2 game)
AUTO_START_SECONDS = int(os.getenv("AUTO_START_SECONDS", "60"))   # ƒë·∫øm ng∆∞·ª£c s·∫£nh
REMIND_EVERY_SECONDS = int(os.getenv("REMIND_EVERY_SECONDS", "30"))

# Th·ªùi gian m·ªói l∆∞·ª£t
TURN_SECONDS_WORDCHAIN = int(os.getenv("TURN_SECONDS_WORDCHAIN", "30"))
TURN_SECONDS_GUESS     = int(os.getenv("TURN_SECONDS_GUESS", "30"))

# Gist chung
GIST_ID    = os.getenv("GIST_ID", "").strip()
GIST_TOKEN = os.getenv("GIST_TOKEN", "").strip()

# File ri√™ng trong c√πng 1 Gist (KH√îNG l·∫´n nhau)
GIST_DICT_FILE  = os.getenv("GIST_DICT_FILE",  "dict_offline.txt")     # Game ƒê·ªëi Ch·ªØ: l∆∞u c·ª•m ƒë√∫ng
GIST_GUESS_FILE = os.getenv("GIST_GUESS_FILE", "guess_clue_bank.json") # Game ƒêo√°n Ch·ªØ: ng√¢n h√†ng c√¢u (clue/answer)

# (tu·ª≥ ch·ªçn) ngu·ªìn t·ª´ ƒëi·ªÉn offline b·ªï sung
OFFLINE_DICT_URL  = os.getenv("OFFLINE_DICT_URL", "").strip()
OFFLINE_DICT_FILE = os.getenv("OFFLINE_DICT_FILE", "dict_vi.txt")

# Soha
SOHA_BASE = "http://tratu.soha.vn"

# L·ªánh ph·ª•
ONLY_PING_USER = "@yhck2"  # cho /iu Easter egg

# =========== TI·ªÜN √çCH CHUNG ===========
def normspace(s: str) -> str:
    return re.sub(r"\s+", " ", (s or "").strip())

def is_two_words_vi(s: str) -> bool:
    s = normspace(s)
    parts = s.split(" ")
    return len(parts) == 2 and all(p for p in parts)

def first_last_word(s: str) -> Tuple[str, str]:
    s = normspace(s)
    a, b = s.split(" ")
    return a, b

def both_keys(s: str) -> Tuple[str, str]:
    s = normspace(s).lower()
    return s, unidecode(s)

def md_mention(uid: int, name: str) -> str:
    return f"[{name}](tg://user?id={uid})"

# =========== GIST I/O ===========
def _gist_headers():
    h = {"Accept": "application/vnd.github+json"}
    if GIST_TOKEN:
        h["Authorization"] = f"token {GIST_TOKEN}"
    return h

def gist_read_file(filename: str) -> Optional[str]:
    if not GIST_ID:
        return None
    try:
        g = requests.get(f"https://api.github.com/gists/{GIST_ID}", headers=_gist_headers(), timeout=12).json()
        files = g.get("files", {})
        if filename in files and files[filename].get("content") is not None:
            return files[filename]["content"]
        # n·∫øu kh√¥ng c√≥ "content" nh∆∞ng c√≥ raw_url
        if filename in files and files[filename].get("raw_url"):
            raw = files[filename]["raw_url"]
            r = requests.get(raw, timeout=12)
            if r.ok:
                return r.text
    except Exception as e:
        log.warning("gist_read_file(%s) error: %s", filename, e)
    return None

def gist_write_file(filename: str, content: str) -> bool:
    if not GIST_ID or not GIST_TOKEN:
        return False
    try:
        payload = {"files": {filename: {"content": content}}}
        r = requests.patch(f"https://api.github.com/gists/{GIST_ID}",
                           headers=_gist_headers(), data=json.dumps(payload), timeout=15)
        return r.ok
    except Exception as e:
        log.warning("gist_write_file(%s) error: %s", filename, e)
        return False

# =========== /start v·ªõi 2 n√∫t ===========
def start_keyboard():
    kb = [
        [
            InlineKeyboardButton("üéÆ Game ƒê·ªëi Ch·ªØ", callback_data="choose_wordchain"),
            InlineKeyboardButton("üß† Game ƒêo√°n Ch·ªØ", callback_data="choose_guess"),
        ]
    ]
    return InlineKeyboardMarkup(kb)

async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.effective_message.reply_text(
        "Xin ch√†o! Ch·ªçn tr√≤ b·∫°n mu·ªën ch∆°i:",
        reply_markup=start_keyboard()
    )

# =========== TR·∫†NG TH√ÅI CH·ªåN GAME & LOBBY ===========
# l∆∞u game ƒë√£ ch·ªçn g·∫ßn nh·∫•t theo chat (ƒë·ªÉ /newgame bi·∫øt l√†m game n√†o)
LAST_GAME: Dict[int, str] = {}  # chat_id -> "wordchain"|"guess"

# lobby: chat_id -> state
LOBBY: Dict[int, Dict] = {}

async def on_choose_game(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    chat = update.effective_chat

    if q.data == "choose_wordchain":
        LAST_GAME[chat.id] = "wordchain"
        text = (
            "üéÆ **Game ƒê·ªëi Ch·ªØ**\n"
            "‚Ä¢ Lu·∫≠t: d√πng **c·ª•m 2 t·ª´ c√≥ nghƒ©a** (c√≥ d·∫•u). Ng∆∞·ªùi sau **ph·∫£i b·∫Øt ƒë·∫ßu b·∫±ng t·ª´ cu·ªëi** c·ªßa c·ª•m tr∆∞·ªõc.\n"
            f"‚Ä¢ M·ªói l∆∞·ª£t {TURN_SECONDS_WORDCHAIN}s, sai/kh√¥ng c√≥ nghƒ©a/h·∫øt gi·ªù ‚áí b·ªã lo·∫°i.\n"
            "‚Ä¢ 1 ng∆∞·ªùi tham gia ‚Üí ch∆°i m·ªôt m√¨nh (BOT l√†m tr·ªçng t√†i).\n"
            "‚Ä¢ ‚â•2 ng∆∞·ªùi ‚Üí ƒë·∫•u v·ªõi nhau, BOT l√†m tr·ªçng t√†i.\n\n"
            "L·ªánh: /newgame (m·ªü s·∫£nh) ‚Ä¢ /join (tham gia) ‚Ä¢ /begin (b·∫Øt ƒë·∫ßu) ‚Ä¢ /stop (d·ª´ng)"
        )
        await q.message.reply_text(text, parse_mode=ParseMode.MARKDOWN)
    else:
        LAST_GAME[chat.id] = "guess"
        text = (
            "üß† **Game ƒêo√°n Ch·ªØ** (ca dao, th√†nh ng·ªØ)\n"
            "‚Ä¢ M·ªói ng∆∞·ªùi c√≥ **3 l∆∞·ª£t ƒëo√°n** theo v√≤ng. H·∫øt 3 l∆∞·ª£t m√† ch∆∞a ƒë√∫ng ‚áí **b·ªã lo·∫°i**.\n"
            f"‚Ä¢ M·ªói l∆∞·ª£t {TURN_SECONDS_GUESS}s; h·∫øt gi·ªù t√≠nh nh∆∞ m·ªôt l∆∞·ª£t sai.\n"
            "‚Ä¢ Ch·ªâ c·∫ßn 1 ng∆∞·ªùi c≈©ng ch∆°i ƒë∆∞·ª£c.\n"
            "‚Ä¢ Kh√¥ng ai ƒëo√°n ƒë√∫ng sau khi t·∫•t c·∫£ d√πng h·∫øt l∆∞·ª£t ‚áí k·∫øt th√∫c v√† c√¥ng b·ªë ƒë√°p √°n.\n\n"
            "L·ªánh: /newgame (m·ªü s·∫£nh) ‚Ä¢ /join (tham gia) ‚Ä¢ /begin (b·∫Øt ƒë·∫ßu) ‚Ä¢ /stop (d·ª´ng)"
        )
        await q.message.reply_text(text, parse_mode=ParseMode.MARKDOWN)

# =========== LOBBY CHUNG ===========
async def cmd_newgame(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    g = LAST_GAME.get(chat.id)
    if not g:
        await update.effective_message.reply_text("H√£y /start v√† ch·ªçn tr√≤ tr∆∞·ªõc ƒë√£ nh√©.")
        return
    # reset lobby n·∫øu c√≥
    old = LOBBY.get(chat.id)
    if old:
        try:
            if old.get("count_job"): old["count_job"].schedule_removal()
            if old.get("rem_job"): old["rem_job"].schedule_removal()
        except: ...
        LOBBY.pop(chat.id, None)

    LOBBY[chat.id] = {
        "game": g,
        "players": set(),
        "created": time.time(),
        "count_job": context.job_queue.run_once(_auto_begin_job, when=AUTO_START_SECONDS, chat_id=chat.id),
        "rem_job": context.job_queue.run_repeating(_remind_job, interval=REMIND_EVERY_SECONDS,
                                                   first=REMIND_EVERY_SECONDS, chat_id=chat.id),
    }
    await update.effective_message.reply_text(
        f"üéÆ M·ªü s·∫£nh **{ 'Game ƒê·ªëi Ch·ªØ' if g=='wordchain' else 'Game ƒêo√°n Ch·ªØ' }**!\n"
        f"‚Ä¢ /join ƒë·ªÉ tham gia ‚Ä¢ t·ª± b·∫Øt ƒë·∫ßu sau {AUTO_START_SECONDS}s.",
        parse_mode=ParseMode.MARKDOWN
    )

async def _remind_job(ctx: ContextTypes.DEFAULT_TYPE):
    chat_id = ctx.job.chat_id
    st = LOBBY.get(chat_id)
    if not st: return
    remain = max(0, AUTO_START_SECONDS - int(time.time() - st["created"]))
    if remain <= 0: return
    msg = random.choice([
        "‚è≥ Mau mau /join n√†o!",
        "‚åõ S·∫Øp h·∫øt gi·ªù ch·ªù r·ªìi!",
        "üïí L·ª° s·∫£nh l√† ƒë·ª£i v√°n sau nh√©!",
        "üì£ G·ªçi ƒë·ªìng ƒë·ªôi v√¥ ch∆°i ƒëi!",
        "üé≤ V√†o ƒë√¥ng vui h∆°n m√†!",
    ]) + f"\nüï∞Ô∏è C√≤n {remain}s!"
    await ctx.application.bot.send_message(chat_id, msg)

async def _auto_begin_job(ctx: ContextTypes.DEFAULT_TYPE):
    chat_id = ctx.job.chat_id
    app = ctx.application
    st = LOBBY.get(chat_id)
    if not st: return
    # h·ªßy job nh·∫Øc
    try:
        if st.get("rem_job"): st["rem_job"].schedule_removal()
    except: ...
    players = list(st["players"])
    game = st["game"]
    LOBBY.pop(chat_id, None)

    if len(players) == 0:
        await app.bot.send_message(chat_id, "‚åõ H·∫øt gi·ªù m√† ch∆∞a c√≥ ai /join. ƒê√≥ng s·∫£nh!")
        return

    if game == "wordchain":
        await start_wordchain(app, chat_id, players)
    else:
        await start_guess(app, chat_id, players)

async def cmd_join(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    st = LOBBY.get(chat_id)
    if not st:
        await update.effective_message.reply_text("‚ùå Ch∆∞a c√≥ s·∫£nh. /start ‚Üí ch·ªçn tr√≤ ‚Üí /newgame.")
        return
    st["players"].add(update.effective_user.id)
    await update.effective_message.reply_text(
        f"‚úÖ {update.effective_user.full_name} ƒë√£ tham gia!"
    )

async def cmd_begin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    st = LOBBY.get(chat_id)
    if not st:
        await update.effective_message.reply_text("‚ùå Ch∆∞a c√≥ s·∫£nh. /start ‚Üí ch·ªçn tr√≤ ‚Üí /newgame.")
        return
    try:
        if st.get("count_job"): st["count_job"].schedule_removal()
        if st.get("rem_job"): st["rem_job"].schedule_removal()
    except: ...
    players = list(st["players"])
    game = st["game"]
    LOBBY.pop(chat_id, None)
    if len(players) == 0:
        await update.effective_message.reply_text("‚åõ Ch∆∞a c√≥ ai /join. Hu·ª∑ b·∫Øt ƒë·∫ßu.")
        return
    if game == "wordchain":
        await start_wordchain(context.application, chat_id, players)
    else:
        await start_guess(context.application, chat_id, players)

async def cmd_stop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    # d·ªçn lobby
    st = LOBBY.pop(chat_id, None)
    if st:
        try:
            if st.get("count_job"): st["count_job"].schedule_removal()
            if st.get("rem_job"): st["rem_job"].schedule_removal()
        except: ...
    # d·ªçn game
    WORDCHAIN.pop(chat_id, None)
    GUESS.pop(chat_id, None)
    await update.effective_message.reply_text("üõë ƒê√£ d·ª´ng v√°n / d·ªçn s·∫£nh.")

# =========== GAME 1: ƒê·ªêI CH·ªÆ ===========
# cache t·ª´ ƒë√∫ng / sai
DICT_OK: Set[str] = set()
DICT_BAD: Set[str] = set()

def load_offline_dict():
    seen = 0
    try:
        if OFFLINE_DICT_URL:
            r = requests.get(OFFLINE_DICT_URL, timeout=10)
            if r.ok:
                lines = r.text.splitlines()
            else:
                lines = []
        elif os.path.exists(OFFLINE_DICT_FILE):
            with open(OFFLINE_DICT_FILE, "r", encoding="utf-8") as f:
                lines = f.readlines()
        else:
            lines = []
        for ln in lines:
            w = normspace(ln).lower()
            if is_two_words_vi(w):
                DICT_OK.update([w, unidecode(w)])
                seen += 1
        log.info("Offline dict loaded: %d entries", seen)
    except Exception as e:
        log.warning("load_offline_dict err: %s", e)

def save_good_phrase_to_gist(phrase: str):
    """Append phrase v√†o GIST_DICT_FILE n·∫øu ch∆∞a c√≥ (c√≥ d·∫•u)."""
    if not (GIST_ID and GIST_TOKEN and GIST_DICT_FILE):
        return
    try:
        cur = gist_read_file(GIST_DICT_FILE) or ""
        lines = [l.strip().lower() for l in cur.splitlines() if l.strip()]
        p = normspace(phrase).lower()
        if p not in lines:
            new = (cur + ("\n" if cur and not cur.endswith("\n") else "") + phrase.strip() + "\n")
            gist_write_file(GIST_DICT_FILE, new)
    except Exception as e:
        log.warning("save_good_phrase_to_gist err: %s", e)

def _norm_vi(s: str) -> str:
    s = normspace(s).lower()
    s = re.sub(r"\s+", " ", s)
    return s

def soha_exact_match(phrase: str) -> bool:
    """Tra exact tr√™n tratu.soha.vn (vn_vn)."""
    phrase = phrase.strip()
    if not phrase:
        return False

    headers = {"User-Agent": "Mozilla/5.0 (TelegramBot/wordchain)"}
    # 1) th·ª≠ trang tr·ª±c ti·∫øp
    try:
        from urllib.parse import quote
        url = f"{SOHA_BASE}/dict/vn_vn/{quote(phrase, safe='')}"
        r = requests.get(url, headers=headers, timeout=8)
        if r.status_code == 200 and r.text:
            soup = BeautifulSoup(r.text, "lxml")
            title = (soup.title.text if soup.title else "")
            if _norm_vi(title).startswith(_norm_vi(phrase)):
                return True
            # th·ª≠ h1/h2/h3
            for tag in soup.find_all(["h1", "h2", "h3"]):
                t = _norm_vi(tag.get_text(" ", strip=True))
                if t == _norm_vi(phrase) or t.startswith(_norm_vi(phrase)):
                    return True
    except Exception:
        pass
    # 2) fallback search
    try:
        from urllib.parse import quote
        surl = f"{SOHA_BASE}/search.php?word={quote(phrase, safe='')}&dict=vn_vn"
        r = requests.get(surl, headers=headers, timeout=8)
        if r.status_code == 200 and r.text:
            soup = BeautifulSoup(r.text, "lxml")
            for a in soup.find_all("a", href=True):
                if "/dict/vn_vn/" in (a["href"] or ""):
                    txt = _norm_vi(a.get_text(" ", strip=True))
                    if txt == _norm_vi(phrase):
                        return True
    except Exception:
        pass
    return False

def is_valid_phrase(phrase: str) -> bool:
    phrase = normspace(phrase)
    if not is_two_words_vi(phrase):
        return False
    key_lc, key_no = both_keys(phrase)
    if key_lc in DICT_BAD or key_no in DICT_BAD:
        return False
    if key_lc in DICT_OK or key_no in DICT_OK:
        return True
    # online soha
    if soha_exact_match(phrase):
        DICT_OK.update([key_lc, key_no])
        save_good_phrase_to_gist(phrase)
        return True
    DICT_BAD.update([key_lc, key_no])
    return False

# C√† kh·ªãa (ƒê·ªëi ch·ªØ) ~15 c√¢u
TAUNT_WORDCHAIN = [
    "√îi tr·ªùi, c·ª•m n√†y m√† c≈©ng d√°m xu·∫•t b·∫£n √†? üòè",
    "Tra kh√¥ng ra lu√¥n ƒë√≥ b·∫°n ∆°i‚Ä¶ v·ªÅ √¥n l·∫°i ch·ªØ nghƒ©a nh√©! üìö",
    "Sai nh∆∞ ch∆∞a t·ª´ng sai! ü§£",
    "C·ª•m n√†y Google c√≤n b·ªëi r·ªëi n·ªØa l√† m√¨nh üòÖ",
    "B·∫°n ∆°i, ch·ªØ v·ªõi nghƒ©a gi·∫≠n b·∫°n r·ªìi ƒë√≥! üôÉ",
    "C·ª•m n√†y nghe l·∫° tai ph·∫øt‚Ä¶ nh∆∞ng l√† sai nha! ü§≠",
    "Kh√¥ng c√≥ nghƒ©a ƒë√¢u, ƒë·ª´ng c·ªë ch·∫•p n·ªØa b·∫°n th√¢n ∆°i üòå",
    "Ch·ªØ qu·ªëc ng·ªØ kh√≥ qu√° th√¨ m√¨nh ch∆°i v·∫ßn kh√°c ha? üòú",
    "C·ª•m n√†y g√µ Soha n√≥ c≈©ng ng·∫©n ng∆∞·ªùi lu√¥n! ü•≤",
    "Sai r·ªìi nha, ƒë·ªïi chi·∫øn thu·∫≠t ƒëi n√®! üß†",
    "Gi·∫±ng co chi, sai l√† sai nha b·∫°n! üòÜ",
    "Tr·∫≠t l·∫•t nghe ch∆∞a‚Ä¶ th√™m ch·∫•t x√°m n√†o! üí°",
    "∆† k√¨a, c·ª•m n√†y nh√¨n l√† th·∫•y sai t·ª´ xa r·ªìi! üïµÔ∏è",
    "ƒê·ª´ng l√†m t·ª´ ƒëi·ªÉn kh√≥c n·ªØa! üò¢",
    "Ki·∫øn th·ª©c l√† v√¥ h·∫°n, c√≤n c·ª•m n√†y l√† v√¥ nghƒ©a! üåÄ",
]

class WordChainGame:
    def __init__(self, chat_id: int, players: List[int]):
        self.chat_id = chat_id
        self.players = deque(players)   # multi
        self.mode = "solo" if len(players) == 1 else "multi"
        self.current = self.players[0]
        self.tail: Optional[str] = None
        self.used: Set[str] = set()
        self.turn_job = None

    def rotate(self):
        self.players.rotate(-1)
        self.current = self.players[0]

WORDCHAIN: Dict[int, WordChainGame] = {}

async def start_wordchain(app: Application, chat_id: int, players: List[int]):
    random.shuffle(players)
    gs = WordChainGame(chat_id, players)
    WORDCHAIN[chat_id] = gs
    if gs.mode == "solo":
        await app.bot.send_message(
            chat_id,
            f"üßç **Game ƒê·ªëi Ch·ªØ** (solo)\n"
            f"‚Ä¢ G·ª≠i **c·ª•m 2 t·ª´ c√≥ nghƒ©a** b·∫•t k·ª≥.\n"
            f"‚Ä¢ L∆∞·ª£t sau ph·∫£i b·∫Øt ƒë·∫ßu b·∫±ng **t·ª´ cu·ªëi** c·ªßa c·ª•m tr∆∞·ªõc.\n"
            f"‚Ä¢ M·ªói l∆∞·ª£t {TURN_SECONDS_WORDCHAIN}s.",
            parse_mode=ParseMode.MARKDOWN
        )
    else:
        await app.bot.send_message(
            chat_id,
            f"üë• **Game ƒê·ªëi Ch·ªØ** (nhi·ªÅu ng∆∞·ªùi)\n"
            f"‚Ä¢ Ng∆∞·ªùi m·ªü m√†n: {md_mention(gs.current, 'ng∆∞·ªùi n√†y')}\n"
            f"‚Ä¢ G·ª≠i **c·ª•m 2 t·ª´ c√≥ nghƒ©a**, sau ƒë√≥ ƒë·ªëi b·∫±ng **t·ª´ cu·ªëi**.\n"
            f"‚Ä¢ M·ªói l∆∞·ª£t {TURN_SECONDS_WORDCHAIN}s.",
            parse_mode=ParseMode.MARKDOWN
        )
    await announce_wordchain_turn(app, gs)

async def announce_wordchain_turn(app: Application, gs: WordChainGame):
    if gs.mode == "solo":
        msg = "‚ú® G·ª≠i **c·ª•m 2 t·ª´ c√≥ nghƒ©a**" + (f" (b·∫Øt ƒë·∫ßu b·∫±ng **{gs.tail}**)" if gs.tail else "") + "."
        await app.bot.send_message(gs.chat_id, msg, parse_mode=ParseMode.MARKDOWN)
    else:
        msg = (f"üéØ L∆∞·ª£t c·ªßa {md_mention(gs.current, 'ng∆∞·ªùi n√†y')}"
               + (f" ‚Äî b·∫Øt ƒë·∫ßu b·∫±ng **{gs.tail}**." if gs.tail else " ‚Äî m·ªü m√†n, g·ª≠i c·ª•m b·∫•t k·ª≥."))
        await app.bot.send_message(gs.chat_id, msg, parse_mode=ParseMode.MARKDOWN)
    await schedule_wordchain_timers(app, gs)

async def schedule_wordchain_timers(app: Application, gs: WordChainGame):
    # hu·ª∑ job c≈©
    try:
        if gs.turn_job: gs.turn_job.schedule_removal()
    except: ...
    # nh·∫Øc 5s c√≤n l·∫°i + timeout
    async def remind(ctx: ContextTypes.DEFAULT_TYPE):
        await app.bot.send_message(gs.chat_id, "‚è∞ C√≤n 5 gi√¢y!")
    async def timeout(ctx: ContextTypes.DEFAULT_TYPE):
        if gs.mode == "multi":
            kicked = gs.current
            await app.bot.send_message(gs.chat_id,
                f"‚è±Ô∏è H·∫øt gi·ªù! {md_mention(kicked, 'ng∆∞·ªùi n√†y')} b·ªã lo·∫°i.",
                parse_mode=ParseMode.MARKDOWN)
            try: gs.players.remove(kicked)
            except: ...
            if len(gs.players) <= 1:
                if len(gs.players) == 1:
                    await app.bot.send_message(gs.chat_id, f"üèÜ {md_mention(gs.players[0],'ng∆∞·ªùi n√†y')} v√¥ ƒë·ªãch!",
                                               parse_mode=ParseMode.MARKDOWN)
                else:
                    await app.bot.send_message(gs.chat_id, "üèÅ Kh√¥ng c√≤n ng∆∞·ªùi ch∆°i. K·∫øt th√∫c v√°n.")
                WORDCHAIN.pop(gs.chat_id, None); return
            gs.current = gs.players[0]
            await announce_wordchain_turn(app, gs)
        else:
            await app.bot.send_message(gs.chat_id, "‚è±Ô∏è H·∫øt gi·ªù! K·∫øt th√∫c v√°n (solo).")
            WORDCHAIN.pop(gs.chat_id, None)

    app.job_queue.run_once(remind, when=TURN_SECONDS_WORDCHAIN-5, chat_id=gs.chat_id)
    gs.turn_job = app.job_queue.run_once(timeout, when=TURN_SECONDS_WORDCHAIN, chat_id=gs.chat_id)

def _wc_fail_reason(phrase: str, gs: WordChainGame) -> Optional[str]:
    phrase = normspace(phrase)
    if not is_two_words_vi(phrase):
        return "C√¢u ph·∫£i g·ªìm **2 t·ª´**."
    if gs.tail:
        a, b = first_last_word(phrase)
        if a.lower() != gs.tail.lower():
            return f"C√¢u ph·∫£i b·∫Øt ƒë·∫ßu b·∫±ng **{gs.tail}**."
    if phrase.lower() in gs.used:
        return "C·ª•m ƒë√£ d√πng r·ªìi."
    if not is_valid_phrase(phrase):
        return "C·ª•m kh√¥ng c√≥ nghƒ©a tr√™n t·ª´ ƒëi·ªÉn."
    return None

async def on_text_wordchain(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    if chat.type not in (ChatType.GROUP, ChatType.SUPERGROUP): return
    gs = WORDCHAIN.get(chat.id)
    if not gs: return

    uid = update.effective_user.id
    text = (update.effective_message.text or "").strip()

    # multi: ch·ªâ ng∆∞·ªùi ƒë·∫øn l∆∞·ª£t
    if gs.mode == "multi" and uid != gs.current:
        return

    reason = _wc_fail_reason(text, gs)
    if reason:
        # c√† kh·ªãa + lo·∫°i
        taunt = random.choice(TAUNT_WORDCHAIN)
        if gs.mode == "multi":
            await update.effective_message.reply_text(
                f"{taunt}\n‚ùå {reason}\n‚û°Ô∏è {md_mention(uid,'b·∫°n')} b·ªã lo·∫°i.",
                parse_mode=ParseMode.MARKDOWN
            )
            try: gs.players.remove(uid)
            except: ...
            if len(gs.players) <= 1:
                if len(gs.players) == 1:
                    await context.bot.send_message(chat.id, f"üèÜ {md_mention(gs.players[0],'ng∆∞·ªùi n√†y')} v√¥ ƒë·ªãch!",
                                                   parse_mode=ParseMode.MARKDOWN)
                else:
                    await context.bot.send_message(chat.id, "üèÅ Kh√¥ng c√≤n ng∆∞·ªùi ch∆°i. K·∫øt th√∫c v√°n.")
                WORDCHAIN.pop(chat.id, None); return
            gs.current = gs.players[0]
            await announce_wordchain_turn(context.application, gs)
        else:
            await update.effective_message.reply_text(f"{taunt}\nüëë K·∫øt th√∫c v√°n (solo).",
                                                      parse_mode=ParseMode.MARKDOWN)
            WORDCHAIN.pop(chat.id, None)
        return

    # h·ª£p l·ªá
    gs.used.add(text.lower())
    _, tail = first_last_word(text)
    gs.tail = tail
    await update.effective_message.reply_text("‚úÖ H·ª£p l·ªá, ti·∫øp t·ª•c!", parse_mode=ParseMode.MARKDOWN)

    if gs.mode == "multi":
        gs.rotate()
    await announce_wordchain_turn(context.application, gs)

# =========== GAME 2: ƒêO√ÅN CH·ªÆ (ca dao/ th√†nh ng·ªØ) ===========
# c·∫•u tr√∫c c√¢u h·ªèi: {"clue": "...", "answer": "..."}
DEFAULT_CLUES = [
    {"clue": "ƒÇn qu·∫£ nh·ªõ k·∫ª tr·ªìng c√¢y (ƒëi·ªÅn 4 ch·ªØ)", "answer": "u·ªëng n∆∞·ªõc nh·ªõ ngu·ªìn"},
    {"clue": "M·ªôt c√¢y l√†m ch·∫≥ng n√™n non, ... (ho√†n thi·ªán c√¢u)", "answer": "ba c√¢y ch·ª•m l·∫°i n√™n h√≤n n√∫i cao"},
    {"clue": "ƒêi·ªÅn t·ª•c ng·ªØ v·ªÅ h·ªçc t·∫≠p: 'C√≥ c√¥ng m√†i s·∫Øt ...'", "answer": "c√≥ ng√†y n√™n kim"},
]

def load_guess_bank() -> List[Dict[str,str]]:
    txt = gist_read_file(GIST_GUESS_FILE)
    if not txt:
        # n·∫øu ch∆∞a c√≥, t·∫°o m·∫∑c ƒë·ªãnh
        gist_write_file(GIST_GUESS_FILE, json.dumps(DEFAULT_CLUES, ensure_ascii=False, indent=2))
        return DEFAULT_CLUES.copy()
    try:
        data = json.loads(txt)
        if isinstance(data, list):
            return [x for x in data if isinstance(x, dict) and "clue" in x and "answer" in x]
        return DEFAULT_CLUES.copy()
    except Exception:
        return DEFAULT_CLUES.copy()

def save_guess_bank(bank: List[Dict[str,str]]):
    gist_write_file(GIST_GUESS_FILE, json.dumps(bank, ensure_ascii=False, indent=2))

def equal_answer(a: str, b: str) -> bool:
    # So s√°nh kh√¥ng ph√¢n bi·ªát hoa/th∆∞·ªùng & kh√¥ng d·∫•u & b·ªè kho·∫£ng tr·∫Øng th·ª´a
    def norm(x: str):
        return re.sub(r"\s+"," ", unidecode(x.strip().lower()))
    return norm(a) == norm(b)

# c√† kh·ªãa ƒëo√°n ch·ªØ
TAUNT_GUESS = [
    "Tr∆∞·ª£t nh·∫π th√¥i m√† ƒëau c·∫£ l√≤ng üòÜ",
    "∆† k√¨a, ƒëo√°n m√π √† b·∫°n ∆°i? üôÑ",
    "G·∫ßn ƒë√∫ng‚Ä¶ ·ªü v≈© tr·ª• song song ü§≠",
    "C√¢u n√†y m√† c≈©ng h·ª•t th√¨ th√¥i xin lu√¥n! üòÇ",
    "Sai r·ªìi n√®, ƒë·ª´ng cay c√∫ nha! üòú",
    "Th√™m x√≠u mu·ªëi i-·ªët cho n√£o n√†o! üßÇüß†",
    "ƒêo√°n h√™n xui h·∫£? H∆°i xui ƒë√≥! üçÄ",
    "B·∫°n ∆°i, kh√¥ng ph·∫£i ƒë√¢u nha~ üòù",
    "∆†n gi·ªùi, c√¢u sai ƒë√¢y r·ªìi! ü§°",
    "H·ª•t m·∫•t r·ªìi, l√†m v√°n n·ªØa kh√¥ng? üé≤",
    "Sai m·∫•t r·ªìi, t·∫≠p trung n√†o! üîé",
    "L·ªách kha kh√° ƒë√≥ b·∫°n ∆°i! üß≠",
    "Kh√¥ng ph·∫£i ƒë√°p √°n, th·ª≠ h∆∞·ªõng kh√°c xem! üß©",
    "·∫§m ·ªõ h·ªôi t·ªÅ qu√° nha! üòÖ",
    "Tr·∫≠t l·∫•t r·ªìi‚Ä¶ nh∆∞ng v·∫´n ƒë√°ng y√™u! üíñ",
]

class GuessGame:
    def __init__(self, chat_id: int, players: List[int], bank: List[Dict[str,str]]):
        self.chat_id = chat_id
        self.players = deque(players) if players else deque([])
        self.turn_seconds = TURN_SECONDS_GUESS
        # m·ªói ng∆∞·ªùi c√≥ 3 l∆∞·ª£t
        self.remain: Dict[int,int] = {pid: 3 for pid in players} if players else {}
        self.current: Optional[int] = self.players[0] if players else None
        self.bank = bank
        self.used_idx: Set[int] = set()
        self.q_idx: Optional[int] = None
        self.turn_job = None

    def next_player(self):
        # b·ªè nh·ªØng ai h·∫øt l∆∞·ª£t (0) ra kh·ªèi v√≤ng
        while self.players and self.remain.get(self.players[0],0) <= 0:
            self.players.popleft()
        if not self.players:
            self.current = None
            return
        self.players.rotate(-1)
        while self.players and self.remain.get(self.players[0],0) <= 0:
            self.players.popleft()
        self.current = self.players[0] if self.players else None

GUESS: Dict[int, GuessGame] = {}

def pick_new_question(gs: GuessGame) -> bool:
    # l·∫•y ng·∫´u nhi√™n c√¢u ch∆∞a d√πng
    idxs = [i for i in range(len(gs.bank)) if i not in gs.used_idx]
    if not idxs:
        return False
    gs.q_idx = random.choice(idxs)
    gs.used_idx.add(gs.q_idx)
    return True

async def start_guess(app: Application, chat_id: int, players: List[int]):
    bank = load_guess_bank()
    gs = GuessGame(chat_id, players, bank)
    GUESS[chat_id] = gs

    await app.bot.send_message(
        chat_id,
        f"üß† **Game ƒêo√°n Ch·ªØ**\n"
        f"‚Ä¢ M·ªói ng∆∞·ªùi c√≥ **3 l∆∞·ª£t ƒëo√°n** theo v√≤ng. H·∫øt 3 l∆∞·ª£t m√† ch∆∞a ƒë√∫ng ‚áí b·ªã lo·∫°i.\n"
        f"‚Ä¢ M·ªói l∆∞·ª£t {TURN_SECONDS_GUESS}s; h·∫øt gi·ªù t√≠nh nh∆∞ 1 l·∫ßn sai.\n"
        f"‚Ä¢ N·∫øu t·∫•t c·∫£ h·∫øt l∆∞·ª£t m√† kh√¥ng ai ƒë√∫ng ‚áí c√¥ng b·ªë ƒë√°p √°n v√† k·∫øt th√∫c.",
        parse_mode=ParseMode.MARKDOWN
    )
    if not pick_new_question(gs):
        await app.bot.send_message(chat_id, "Kh√¥ng c√≤n c√¢u h·ªèi trong ng√¢n h√†ng. H√£y b·ªï sung v√†o Gist!")
        GUESS.pop(chat_id, None); return

    clue = gs.bank[gs.q_idx]["clue"]
    await app.bot.send_message(chat_id, f"‚ùì C√¢u h·ªèi: **{clue}**", parse_mode=ParseMode.MARKDOWN)
    await announce_guess_turn(app, gs)

async def announce_guess_turn(app: Application, gs: GuessGame):
    # Ch·ªçn ng∆∞·ªùi hi·ªán t·∫°i (b·ªè ai h·∫øt l∆∞·ª£t)
    while gs.players and gs.remain.get(gs.players[0],0) <= 0:
        gs.players.popleft()
    if not gs.players:
        # t·∫•t c·∫£ h·∫øt l∆∞·ª£t ‚Üí c√¥ng b·ªë ƒë√°p √°n
        ans = gs.bank[gs.q_idx]["answer"] if gs.q_idx is not None else "(kh√¥ng c√≥)"
        await app.bot.send_message(gs.chat_id, f"üèÅ H·∫øt l∆∞·ª£t m·ªçi ng∆∞·ªùi.\nüîé ƒê√°p √°n: **{ans}**",
                                   parse_mode=ParseMode.MARKDOWN)
        GUESS.pop(gs.chat_id, None)
        return

    gs.current = gs.players[0]
    await app.bot.send_message(
        gs.chat_id,
        f"üéØ L∆∞·ª£t c·ªßa {md_mention(gs.current,'b·∫°n')} ‚Äî b·∫°n c√≤n **{gs.remain.get(gs.current,0)}** l∆∞·ª£t.",
        parse_mode=ParseMode.MARKDOWN
    )
    await schedule_guess_timers(app, gs)

async def schedule_guess_timers(app: Application, gs: GuessGame):
    # hu·ª∑ job c≈©
    try:
        if gs.turn_job: gs.turn_job.schedule_removal()
    except: ...
    async def remind(ctx: ContextTypes.DEFAULT_TYPE):
        await app.bot.send_message(gs.chat_id, "‚è∞ C√≤n 5 gi√¢y!")
    async def timeout(ctx: ContextTypes.DEFAULT_TYPE):
        # h·∫øt gi·ªù: tr·ª´ 1 l∆∞·ª£t
        if gs.current is None:
            return
        gs.remain[gs.current] = max(0, gs.remain.get(gs.current,0) - 1)
        await app.bot.send_message(gs.chat_id,
            f"‚è±Ô∏è H·∫øt gi·ªù! {md_mention(gs.current,'b·∫°n')} m·∫•t 1 l∆∞·ª£t (c√≤n {gs.remain[gs.current]}).",
            parse_mode=ParseMode.MARKDOWN
        )
        # chuy·ªÉn l∆∞·ª£t
        gs.next_player()
        await announce_guess_turn(app, gs)

    app.job_queue.run_once(remind, when=TURN_SECONDS_GUESS-5, chat_id=gs.chat_id)
    gs.turn_job = app.job_queue.run_once(timeout, when=TURN_SECONDS_GUESS, chat_id=gs.chat_id)

async def on_text_guess(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    if chat.type not in (ChatType.GROUP, ChatType.SUPERGROUP): return
    gs = GUESS.get(chat.id)
    if not gs: return

    uid = update.effective_user.id
    if uid != gs.current:
        return  # kh√¥ng ph·∫£i l∆∞·ª£t c·ªßa b·∫°n

    text = (update.effective_message.text or "").strip()
    if not text:
        return
    # ch·∫•m
    ans = gs.bank[gs.q_idx]["answer"] if gs.q_idx is not None else ""
    if equal_answer(text, ans):
        await update.effective_message.reply_text(
            f"üéâ Ch√≠nh x√°c! {md_mention(uid,'b·∫°n')} tr·∫£ l·ªùi ƒë√∫ng!\nüèÅ K·∫øt th√∫c c√¢u!",
            parse_mode=ParseMode.MARKDOWN
        )
        GUESS.pop(chat.id, None)
        return

    # sai ‚Üí tr·ª´ l∆∞·ª£t + c√† kh·ªãa
    gs.remain[uid] = max(0, gs.remain.get(uid,0) - 1)
    taunt = random.choice(TAUNT_GUESS)
    await update.effective_message.reply_text(
        f"{taunt}\n‚ùå Sai r·ªìi! B·∫°n c√≤n **{gs.remain[uid]}** l∆∞·ª£t.",
        parse_mode=ParseMode.MARKDOWN
    )
    # h·∫øt l∆∞·ª£t ng∆∞·ªùi n√†y ‚Üí lo·∫°i kh·ªèi v√≤ng
    if gs.remain[uid] <= 0:
        await context.bot.send_message(chat.id, f"‚õî {md_mention(uid,'b·∫°n')} ƒë√£ d√πng h·∫øt l∆∞·ª£t v√† b·ªã lo·∫°i.",
                                       parse_mode=ParseMode.MARKDOWN)
    # chuy·ªÉn l∆∞·ª£t
    gs.next_player()
    await announce_guess_turn(context.application, gs)

# =========== L·ªÜNH PH·ª§ ===========
async def cmd_iu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user and update.effective_user.username:
        if ("@" + update.effective_user.username).lower() == ONLY_PING_USER.lower():
            await update.effective_message.reply_text("Anh Nam Y√™u Em Thi·ªáu ‚ù§Ô∏è"); return
    await update.effective_message.reply_text("iu g√¨ m√† iu üòè")

# =========== ROUTING TEXT ===========
async def on_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # route text v√†o game t∆∞∆°ng ·ª©ng n·∫øu ƒëang ch∆°i
    chat_id = update.effective_chat.id
    if chat_id in WORDCHAIN:
        await on_text_wordchain(update, context)
    elif chat_id in GUESS:
        await on_text_guess(update, context)
    else:
        # kh√¥ng trong v√°n n√†o ‚Üí b·ªè qua
        pass

# =========== INIT / BUILD ===========
async def initialize(app: Application):
    # n·∫°p offline dict cho ƒê·ªëi Ch·ªØ
    load_offline_dict()
    # n·∫°p bank ƒëo√°n ch·ªØ (n·∫øu r·ªóng th√¨ t·∫°o m·∫∑c ƒë·ªãnh)
    _ = load_guess_bank()
    log.info("Initialized.")

async def stop(app: Application):
    pass

def build_app() -> Application:
    if not BOT_TOKEN:
        raise RuntimeError("Thi·∫øu TELEGRAM_TOKEN")
    app = (
        ApplicationBuilder()
        .token(BOT_TOKEN)
        .rate_limiter(AIORateLimiter())
        .build()
    )

    # start + ch·ªçn game
    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CallbackQueryHandler(on_choose_game, pattern="^choose_(wordchain|guess)$"))

    # lobby chung
    app.add_handler(CommandHandler("newgame", cmd_newgame))
    app.add_handler(CommandHandler("join", cmd_join))
    app.add_handler(CommandHandler("begin", cmd_begin))
    app.add_handler(CommandHandler(["stop","ketthuc"], cmd_stop))

    # l·ªánh vui
    app.add_handler(CommandHandler("iu", cmd_iu))

    # route text
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, on_text))

    return app
