# bot.py ‚Äî ƒê·ªëi ch·ªØ "c·ª•m 2 t·ª´ c√≥ nghƒ©a" + /iu t·ªè t√¨nh (PTB 21.x, webhook)
# - /newgame ho·∫∑c /batdau m·ªü s·∫£nh, ƒë·∫øm ng∆∞·ª£c AUTO_LOBBY gi√¢y
# - 0 join: h·ªßy, 1 join: ch∆°i v·ªõi bot, >=2: bot l√†m tr·ªçng t√†i
# - M·ªói l∆∞·ª£t ROUND_SECONDS (nh·∫Øc ·ªü HALF_TIME)
# - C·ª•m sau ph·∫£i b·∫Øt ƒë·∫ßu b·∫±ng t·ª´ th·ª© 2 c·ªßa c·ª•m tr∆∞·ªõc (kh·ªõp kh√¥ng d·∫•u)
# - Nghƒ©a: c√≥ trong dict_vi.txt / slang_vi.txt (c√≥/kh√¥ng d·∫•u) ho·∫∑c zipf>=GENZ_ZIPF (wordfreq)
# - /iu: ch·ªâ @yhck2 g·ªçi; @xiaoc6789 b·∫•m n√∫t n√†o c≈©ng ‚ÄúEm ƒë·ªìng √Ω !! Y√™u Anh ü•∞‚Äù, ng∆∞·ªùi kh√°c ‚ÄúThi·ªáu ∆°i !! Y√™u Anh Nam ƒêii‚Äù
# - T∆∞∆°ng th√≠ch webhook.py: build_app() tr·∫£ m·ªôt wrapper c√≥ initialize/start/stop/shutdown/process_update

import os, re, json, random, asyncio
from typing import Dict, List, Set, Optional, Tuple
from datetime import datetime

from unidecode import unidecode

try:
    from wordfreq import zipf_frequency
except Exception:
    zipf_frequency = None

from telegram import (
    Update, InlineKeyboardButton, InlineKeyboardMarkup, Message,
)
from telegram.constants import ParseMode
from telegram.ext import (
    Application, ApplicationBuilder, CommandHandler, MessageHandler,
    CallbackQueryHandler, ContextTypes, filters,
)

# =========================
# ENV / CONFIG
# =========================
BOT_TOKEN = os.getenv("TELEGRAM_TOKEN", "").strip()
if not BOT_TOKEN:
    raise RuntimeError("Thi·∫øu TELEGRAM_TOKEN")

ROUND_SECONDS = int(os.getenv("ROUND_SECONDS", "60"))
HALF_TIME     = int(os.getenv("HALF_TIME", "30"))
AUTO_LOBBY    = int(os.getenv("AUTO_LOBBY", "60"))

DICT_FILE  = os.getenv("DICT_VI",  "dict_vi.txt")
SLANG_FILE = os.getenv("SLANG_VI", "slang_vi.txt")
GENZ_ZIPF  = float(os.getenv("GENZ_ZIPF", "2.2"))

SPECIAL_CALLER   = os.getenv("IU_CALLER", "@yhck2").lower()
SPECIAL_ACCEPTOR = os.getenv("IU_ACCEPTOR", "@xiaoc6789").lower()

# =========================
# HELPERS (normalize + dict)
# =========================
def _norm(s: str) -> str:
    s = (s or "").strip().lower()
    return re.sub(r"\s+", " ", s)

def _norm_nodiac(s: str) -> str:
    return _norm(unidecode(s))

def load_list(path: str) -> Set[str]:
    bag: Set[str] = set()
    if not os.path.exists(path):
        return bag
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            t = _norm(line)
            if not t: 
                continue
            bag.add(t)                 # c√≥ d·∫•u
            bag.add(_norm_nodiac(t))   # th√™m b·∫£n kh√¥ng d·∫•u
    return bag

DICT_SET  = load_list(DICT_FILE)
SLANG_SET = load_list(SLANG_FILE)

def is_meaningful_token(tok: str) -> bool:
    if not tok or len(tok) < 2:
        return False
    t1 = _norm(tok)
    t0 = _norm_nodiac(tok)
    if t1 in DICT_SET or t0 in DICT_SET:
        return True
    if t1 in SLANG_SET or t0 in SLANG_SET:
        return True
    if zipf_frequency:
        try:
            if zipf_frequency(t1, "vi") >= GENZ_ZIPF:
                return True
            if t0 != t1 and zipf_frequency(t0, "vi") >= GENZ_ZIPF:
                return True
        except Exception:
            pass
    return False

def is_valid_two_word_phrase(text: str) -> Tuple[bool, str, List[str]]:
    t = _norm(text)
    toks = t.split()
    if len(toks) != 2:
        return False, "‚ùå Ph·∫£i g·ª≠i **c·ª•m 2 t·ª´**.", []
    bad = [w for w in toks if not is_meaningful_token(w)]
    if bad:
        return False, f"‚ùå T·ª´ **{bad[0]}** nghe kh√¥ng c√≥ nghƒ©a (ho·∫∑c hi·∫øm qu√°).", []
    return True, "", toks

def link_rule_ok(prev_tokens: List[str], new_tokens: List[str]) -> Tuple[bool, str]:
    if not prev_tokens:
        return True, ""
    need = _norm_nodiac(prev_tokens[1])
    got  = _norm_nodiac(new_tokens[0])
    if need != got:
        return False, f"‚ùå Sai lu·∫≠t n·ªëi ch·ªØ: ph·∫£i b·∫Øt ƒë·∫ßu b·∫±ng **{prev_tokens[1]} ‚Ä¶**"
    return True, ""

def pick_meaningful_word(exclude_first: str, used: Set[str]) -> Optional[str]:
    pool = [w for w in DICT_SET if " " not in w and len(w) >= 2]
    pool += [w for w in SLANG_SET if " " not in w and len(w) >= 2]
    random.shuffle(pool)
    for cand in pool:
        if _norm_nodiac(cand) == _norm_nodiac(exclude_first):
            continue
        phrase = f"{exclude_first} {cand}"
        if _norm(phrase) not in used:
            return cand
    if zipf_frequency:
        commons = ["ƒë·∫πp","l√™n","xu·ªëng","m·∫°nh","nhanh","v·ªôi","ƒë√£","n·ªØa","li·ªÅn","ngay"]
        random.shuffle(commons)
        for cand in commons:
            if _norm(f"{exclude_first} {cand}") not in used:
                return cand
    return None

# =========================
# MESSAGES
# =========================
LOBBY_TEXT = (
    "Ch√†o nh√≥m!\n"
    "G√µ /join ƒë·ªÉ tham gia. Sau {sec}s n·∫øu:\n"
    "‚Ä¢ 0 ng∆∞·ªùi: ‚ùå H·ªßy v√°n\n"
    "‚Ä¢ 1 ng∆∞·ªùi: ü§ñ B·∫°n ch∆°i v·ªõi bot\n"
    "‚Ä¢ 2+ ng∆∞·ªùi: üëë Bot l√†m tr·ªçng t√†i\n\n"
    "üìò Lu·∫≠t:\n"
    "‚Ä¢ G·ª≠i **c·ª•m 2 t·ª´**\n"
    "‚Ä¢ M·ªói t·ª´ ph·∫£i **c√≥ nghƒ©a** (t·ª´ ƒëi·ªÉn/slang ho·∫∑c ph·ªï d·ª•ng)\n"
    "‚Ä¢ C·ª•m sau **b·∫Øt ƒë·∫ßu b·∫±ng ƒëu√¥i** c·ªßa c·ª•m tr∆∞·ªõc (VD: ‚Äúcon heo‚Äù ‚Üí ‚Äú**heo** n√°i‚Äù)\n"
    "‚Ä¢ Sai lu·∫≠t/h·∫øt gi·ªù ‚Üí lo·∫°i."
)

REMINDERS = [
    "Nhanh nhanh l√™n b·∫°n ∆°i, th·ªùi gian kh√¥ng ch·ªù ai ƒë√¢u!",
    "C√≥ ƒëo√°n ƒë∆∞·ª£c kh√¥ng? Ch·∫≠m th·∫ø!",
    "IQ ch·ªâ ƒë·∫øn th·∫ø th√¥i sao? Nhanh c√°i n√£o l√™n!",
    "Suy nghƒ© g√¨ n·ªØa!!! ƒêo√°n ƒë√™eee!",
    "V·∫´n ch∆∞a c√≥ k·∫øt qu·∫£ sao?? N√£o üê∑ √†!!!",
    "T·ªânh t√°o l√™n n√†o, c∆° h·ªôi ƒëang tr√¥i k√¨a!",
    "B√¨nh tƒ©nh nh∆∞ng ƒë·ª´ng *t·ª´ t·ªën* qu√° b·∫°n ∆°i!",
    "ƒê·∫øm ng∆∞·ª£c r·ªìi ƒë√≥, l√†m ph√°t ch·∫•t l∆∞·ª£ng ƒëi!",
    "ƒê·ªë m·∫πo ch·ª© ƒë√¢u ph·∫£i ƒë·ªë ƒë·ªùi ƒë√¢u ü§≠",
    "Th·ªùi gian l√† v√†ng, c√≤n b·∫°n l√†... b·∫°c ph·∫øch!",
    "G·ª£i √Ω n·∫±m trong b·ªën ch·ªØ: **c·ª•m hai t·ª´**!",
]

OK_CHEERS = [
    "‚úÖ Th√¥i ƒë∆∞·ª£c, c√¥ng nh·∫≠n b·∫°n kh√¥ng g√† l·∫Øm!",
    "‚úÖ Qu√° gh√™, xin nh·∫≠n m·ªôt c√∫ c√∫i ƒë·∫ßu!",
    "‚úÖ Chu·∫©n b√†i, kh·ªèi b√†n!",
    "‚úÖ ƒê·ªânh c·ªßa ch√≥p!",
]

TIME_WARNINGS = [
    "‚è∞ C√∫ l·ª´a √†? Kh√¥ng, ch·ªâ c√≤n **√≠t th·ªùi gian** th√¥i!",
    "‚è∞ Nhanh l√™n, n·ª≠a th·ªùi gian ƒë√£ tr√¥i!",
]

WRONG_FMT = [
    "‚ùå Kh√¥ng ƒë√∫ng. C√≤n {left} l·∫ßn 'tr·∫≠t l·∫•t' n·ªØa!",
    "‚ùå Sai r·ªìi. C√≤n {left} c∆° h·ªôi!",
    "‚ùå No no. C√≤n {left} l·∫ßn!",
    "‚ùå Tr∆∞·ª£t. {left} l·∫ßn c√≤n l·∫°i!",
]

# =========================
# GAME STATE
# =========================
class Game:
    def __init__(self, chat_id: int):
        self.chat_id = chat_id
        self.lobby_open = False
        self.players: List[int] = []
        self.single_vs_bot = False

        self.active = False
        self.prev_tokens: List[str] = []
        self.used: Set[str] = set()
        self.mistakes_left: int = 3
        self.job_ids: List[str] = []

    def clear_jobs(self, context: ContextTypes.DEFAULT_TYPE):
        for jid in list(self.job_ids):
            for j in context.job_queue.get_jobs_by_name(jid):
                j.schedule_removal()
            self.job_ids.clear()

GAMES: Dict[int, Game] = {}

def get_game(chat_id: int) -> Game:
    if chat_id not in GAMES:
        GAMES[chat_id] = Game(chat_id)
    return GAMES[chat_id]

# =========================
# APP FACTORY
# =========================
def make_application() -> Application:
    app = ApplicationBuilder().token(BOT_TOKEN).build()
    app.add_handler(CommandHandler(["start"], cmd_start))
    app.add_handler(CommandHandler(["newgame","batdau"], cmd_newgame))
    app.add_handler(CommandHandler(["join"], cmd_join))
    app.add_handler(CommandHandler(["ketthuc"], cmd_stop))
    app.add_handler(CommandHandler(["iu"], cmd_iu))
    app.add_handler(CallbackQueryHandler(cb_iu_buttons, pattern=r"^iu:(yes|no)$"))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, on_text))
    return app

# =========================
# COMMANDS
# =========================
async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.effective_message.reply_text(
        f"Ch√†o nh√≥m! /newgame ho·∫∑c /batdau ƒë·ªÉ m·ªü s·∫£nh, /join ƒë·ªÉ tham gia, /ketthuc ƒë·ªÉ d·ª´ng.\n"
        f"‚è±Ô∏è M·ªói l∆∞·ª£t {ROUND_SECONDS}s (nh·∫Øc ·ªü {HALF_TIME}s).\n"
        f"T·ª´ ƒëi·ªÉn: ~{len(DICT_SET)//2} m·ª•c, slang: ~{len(SLANG_SET)//2} m·ª•c."
    )

async def cmd_newgame(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    g = get_game(chat_id)
    g.lobby_open = True
    g.players = []
    g.active = False
    g.single_vs_bot = False
    g.prev_tokens = []
    g.used = set()
    g.mistakes_left = 3
    g.clear_jobs(context)

    await update.effective_message.reply_text(LOBBY_TEXT.format(sec=AUTO_LOBBY), parse_mode=ParseMode.MARKDOWN)

    jid = f"lobby:{chat_id}:{datetime.now().timestamp()}"
    g.job_ids.append(jid)
    context.job_queue.run_once(close_lobby, AUTO_LOBBY, chat_id=chat_id, name=jid)

async def cmd_join(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    g = get_game(chat_id)
    u = update.effective_user
    if not g.lobby_open:
        await update.effective_message.reply_text("Kh√¥ng c√≥ s·∫£nh m·ªü. D√πng /newgame tr∆∞·ªõc.")
        return
    if u.id in g.players:
        await update.effective_message.reply_text("B·∫°n ƒë√£ /join r·ªìi!")
        return
    g.players.append(u.id)
    await update.effective_message.reply_html(f"‚úÖ {u.mention_html()} ƒë√£ tham gia!")

async def close_lobby(context: ContextTypes.DEFAULT_TYPE):
    chat_id = context.job.chat_id
    g = get_game(chat_id)
    g.lobby_open = False
    n = len(g.players)
    if n == 0:
        await context.bot.send_message(chat_id, "‚õî Kh√¥ng ai tham gia. H·ªßy v√°n.")
        return
    if n == 1:
        g.single_vs_bot = True
        await context.bot.send_message(chat_id, "ü§ñ Ch·ªâ c√≥ 1 ng∆∞·ªùi. B·∫°n s·∫Ω ch∆°i v·ªõi bot!")
    else:
        g.single_vs_bot = False
        await context.bot.send_message(chat_id, f"üë• C√≥ {n} ng∆∞·ªùi. B·∫Øt ƒë·∫ßu th√¥i!")

    await start_round(chat_id, context)

async def start_round(chat_id: int, context: ContextTypes.DEFAULT_TYPE):
    g = get_game(chat_id)
    g.active = True
    g.prev_tokens = []
    g.used = set()
    g.mistakes_left = 3
    g.clear_jobs(context)

    await context.bot.send_message(
        chat_id,
        "üöÄ B·∫Øt ƒë·∫ßu! G·ª≠i **c·ª•m 2 t·ª´ c√≥ nghƒ©a**. Sai lu·∫≠t/h·∫øt gi·ªù ‚Üí lo·∫°i.",
        parse_mode=ParseMode.MARKDOWN,
    )
    schedule_timers(chat_id, context)

def schedule_timers(chat_id: int, context: ContextTypes.DEFAULT_TYPE):
    g = get_game(chat_id)
    g.clear_jobs(context)

    jid1 = f"half:{chat_id}:{datetime.now().timestamp()}"
    g.job_ids.append(jid1)
    context.job_queue.run_once(half_warn, HALF_TIME, chat_id=chat_id, name=jid1)

    jid2 = f"end:{chat_id}:{datetime.now().timestamp()}"
    g.job_ids.append(jid2)
    context.job_queue.run_once(timeup, ROUND_SECONDS, chat_id=chat_id, name=jid2)

async def half_warn(context: ContextTypes.DEFAULT_TYPE):
    chat_id = context.job.chat_id
    await context.bot.send_message(chat_id, random.choice(TIME_WARNINGS))
    await context.bot.send_message(chat_id, "üí° " + random.choice(REMINDERS))

async def timeup(context: ContextTypes.DEFAULT_TYPE):
    chat_id = context.job.chat_id
    g = get_game(chat_id)
    if not g.active:
        return
    g.active = False
    await context.bot.send_message(chat_id, "‚è≥ H·∫øt gi·ªù! V√°n d·ª´ng ·ªü ƒë√¢y.")

async def cmd_stop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    g = get_game(chat_id)
    g.active = False
    g.lobby_open = False
    g.clear_jobs(context)
    await update.effective_message.reply_text("üõë ƒê√£ k·∫øt th√∫c v√°n.")

# =========================
# /iu ‚Äî t·ªè t√¨nh
# =========================
async def cmd_iu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    user = update.effective_user
    username = ("@" + (user.username or "")).lower()
    if username != SPECIAL_CALLER:
        return
    kb = InlineKeyboardMarkup(
        [[InlineKeyboardButton("ƒê·ªìng √Ω üíö", callback_data="iu:yes"),
          InlineKeyboardButton("Kh√¥ng üíî", callback_data="iu:no")]]
    )
    await context.bot.send_message(chat_id, "Y√™u Em Thi·ªáu ü•∞ L√†m Ng∆∞·ªùi Y√™u Anh Nh√© !!!", reply_markup=kb)

async def cb_iu_buttons(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    if not q:
        return
    await q.answer()
    chat_id = q.message.chat_id
    user = q.from_user
    username = ("@" + (user.username or "")).lower()
    text = "Em ƒë·ªìng √Ω !! Y√™u Anh ü•∞" if username == SPECIAL_ACCEPTOR else "Thi·ªáu ∆°i !! Y√™u Anh Nam ƒêii"
    await q.message.reply_text(text)

# =========================
# NH·∫¨N C√ÇU TR·∫¢ L·ªúI
# =========================
async def on_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    g = get_game(chat_id)
    if not g.active:
        return

    msg: Message = update.effective_message
    text = msg.text or ""

    ok, err, toks = is_valid_two_word_phrase(text)
    if not ok:
        await msg.reply_text(err, parse_mode=ParseMode.MARKDOWN)
        g.mistakes_left -= 1
        if g.mistakes_left <= 0:
            await msg.reply_text("‚ùå H·∫øt c∆° h·ªôi cho c·∫£ nh√≥m. V√°n d·ª´ng.")
            g.active = False
        return

    ok2, err2 = link_rule_ok(g.prev_tokens, toks)
    if not ok2:
        await msg.reply_text(err2)
        g.mistakes_left -= 1
        if g.mistakes_left <= 0:
            await msg.reply_text("‚ùå H·∫øt c∆° h·ªôi cho c·∫£ nh√≥m. V√°n d·ª´ng.")
            g.active = False
        return

    key = _norm(" ".join(toks))
    if key in g.used:
        await msg.reply_text("‚ö†Ô∏è C·ª•m n√†y d√πng r·ªìi, th·ª≠ c√°i kh√°c!")
        return

    # ch·∫•p nh·∫≠n
    g.used.add(key)
    g.prev_tokens = toks
    await msg.reply_text(random.choice(OK_CHEERS))

    # Ch·∫ø ƒë·ªô 1 ng∆∞·ªùi ‚Üí bot ƒë·ªëi l·∫°i
    if g.single_vs_bot:
        tail = toks[1]
        cand2 = pick_meaningful_word(tail, g.used)
        if not cand2:
            await context.bot.send_message(chat_id, "ü§ñ Bot b√≠ r·ªìi‚Ä¶ b·∫°n th·∫Øng!")
            g.active = False
            return
        bot_phrase = f"{tail} {cand2}"
        okb, _, toksb = is_valid_two_word_phrase(bot_phrase)
        if not okb:
            await context.bot.send_message(chat_id, "ü§ñ Bot b√≠ r·ªìi‚Ä¶ b·∫°n th·∫Øng!")
            g.active = False
            return
        g.used.add(_norm(bot_phrase))
        g.prev_tokens = toksb
        await context.bot.send_message(chat_id, f"ü§ñ {bot_phrase}")

    # Reset timers cho l∆∞·ª£t k·∫ø ti·∫øp
    schedule_timers(chat_id, context)

# =========================
# WRAPPER cho webhook.py
# =========================
class TGAppWrapper:
    def __init__(self):
        self.app = make_application()
    async def initialize(self):
        await self.app.initialize()
    async def start(self):
        await self.app.start()
    async def stop(self):
        await self.app.stop()
    async def shutdown(self):
        await self.app.shutdown()
    async def process_update(self, update: Update):
        await self.app.process_update(update)

def build_app():
    # webhook.py s·∫Ω import h√†m n√†y
    return TGAppWrapper()
