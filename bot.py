import os
import random
import asyncio
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple

from unidecode import unidecode
from telegram import Update
from telegram.constants import ParseMode
from telegram.ext import (
    Application, ApplicationBuilder, CommandHandler,
    MessageHandler, ContextTypes, filters
)

# ================== C·∫§U H√åNH / TH√îNG ƒêI·ªÜP ==================
ROUND_SECONDS = int(os.getenv("ROUND_SECONDS", "60"))
HALFTIME_SECONDS = int(os.getenv("HALFTIME_SECONDS", str(ROUND_SECONDS // 2)))
AUTO_BEGIN_SECONDS = int(os.getenv("AUTO_BEGIN_SECONDS", "60"))
DICT_FILE = os.getenv("DICT_FILE", "dict_vi.txt").strip()

HALF_WARNINGS = [
    "C√≤n 30 gi√¢y cu·ªëi ƒë·ªÉ b·∫°n suy nghƒ© v·ªÅ cu·ªôc ƒë·ªùi:))",
    "T·∫Øc ·∫ª ƒë·∫øn v·∫≠y sao, 30 gi√¢y cu·ªëi n√® :||",
    "30 v·∫´n ch∆∞a ph·∫£i T·∫øt, nh∆∞ng mi s·∫Øp h·∫øt gi·ªù r·ªìi. 30 gi√¢y!",
    "M·∫Øc ƒëitt r·∫∑n m√£i kh√¥ng ra. 30 gi√¢y cu·ªëi ·∫ª!",
    "30 gi√¢y cu·ªëi n√≠ ∆°i!"
]
WRONG_ANSWERS = [
    "IQ b·∫°n c·∫ßn ph·∫£i xem x√©t l·∫°i, m·ªùi ti·∫øp !!",
    "M·ªói th·∫ø c≈©ng sai, GG c≈©ng kh√¥ng c·ª©u ƒë∆∞·ª£c !",
    "Sai r·ªìi m√°, tra l·∫°i t·ª´ ƒëi·ªÉn ƒëi !",
    "T·ª´ g√¨ v·∫≠y m√°, h·ªçc l·∫°i l·ªõp 1 ƒëi !!",
    "·∫¢o ti·∫øng Vi·ªát hee",
    "Lo·∫°i, ng∆∞·ªùi ti·∫øp theo!",
    "Ch∆∞a ti·∫øn ho√° h·∫øt √†, t·ª´ n√†y con ng∆∞·ªùi d√πng sao‚Ä¶ Sai b√©t!!"
]
TIMEOUT_MSG = "‚è∞ H·∫øt gi·ªù, m·ªùi b·∫°n ra ngo√†i ch·ªù !!"

# 3 c√¢u ‚Äúnh·∫Øc‚Äù d√†nh cho CH·∫æ ƒê·ªò 1 NG∆Ø·ªúI (sai nh∆∞ng ch∆∞a lo·∫°i ngay)
SOLO_HINTS = [
    "T·ª´ n√†y c√≥ nghƒ©a th·∫≠t kh√¥ng ? Anh nh·∫Øc c∆∞ng",
    "Cho b√© c∆° h·ªôi n·ªØa ,",
    "C∆° h·ªôi cu·ªëi ! N·∫øu sai chu·∫©n b·ªã xu·ªëng h√†ng gh·∫ø ƒë·ªông v·∫≠t ng·ªìi !!!",
]

# ================== N·∫†P T·ª™ ƒêI·ªÇN 2 T·ª™ ==================
def load_dict(path_hint: str = DICT_FILE) -> Set[str]:
    """N·∫°p c·ª•m 2 t·ª´ (m·ªói d√≤ng ƒë√∫ng 2 token ch·ªØ c√°i) t·ª´ file DICT_FILE."""
    search_paths = [
        Path(path_hint),
        Path(__file__).parent / path_hint,
        Path("/opt/render/project/src") / path_hint,  # Render
    ]
    used = None
    ok: Set[str] = set()
    dropped = 0
    for p in search_paths:
        if p.exists():
            used = p
            with p.open("r", encoding="utf-8") as f:
                for line in f:
                    s = " ".join(line.strip().lower().split())
                    if not s:
                        continue
                    parts = s.split()
                    # gi·ªØ ƒë√∫ng 2 token, ƒë·ªÅu l√† ch·ªØ (cho ‚Äú2 t·ª´/2 v·∫ßn‚Äù chu·∫©n)
                    if len(parts) == 2 and all(part.isalpha() for part in parts):
                        ok.add(s)
                    else:
                        dropped += 1
            break
    if used is None:
        print(f"[DICT] ‚ùå Kh√¥ng t√¨m th·∫•y file: {path_hint}")
    else:
        print(f"[DICT] ‚úÖ {used} ‚Äî h·ª£p l·ªá: {len(ok)} | lo·∫°i: {dropped}")
    return ok

DICT: Set[str] = load_dict()

def is_two_word_phrase_in_dict(s: str) -> bool:
    s = " ".join(s.strip().lower().split())
    parts = s.split()
    if len(parts) != 2:
        return False
    if not all(part.isalpha() for part in parts):
        return False
    return s in DICT

# ================== RHYME (V·∫¶N) ==================
# L·∫•y "v·∫ßn" ti·∫øng Vi·ªát x·∫•p x·ªâ: b·ªè d·∫•u, b·ªè ph·ª• √¢m ƒë·∫ßu; gi·ªØ nguy√™n √¢m + ph·ª• √¢m cu·ªëi.
# V√≠ d·ª•: "c√°" -> "a"; "heo" -> "eo"; "trƒÉng" -> "ang"; "qu·ªëc" -> "oc"/"uoc" (x·∫•p x·ªâ).
# L∆∞u √Ω: ƒë√¢y l√† heuristic ƒë·ªß d√πng ƒë·ªÉ ch∆°i; kh√¥ng ph·∫£i b·ªô t√°ch √¢m v·ªã ho√†n h·∫£o.
ONSET_CLUSTERS = [
    "ngh","gh","ng","nh","ch","th","tr","ph","qu","gi","kh","th","qu","qu","quy"
]
CONSONANTS = set(list("bcdfghjklmnpqrstvxƒë"))

def rhyme_key(syllable: str) -> str:
    # chu·∫©n h√≥a: lower, b·ªè d·∫•u thanh (unidecode), gom space
    syl = unidecode(syllable.lower().strip())
    # ƒë·∫∑c bi·ªát: 'qu' v√† 'gi' th∆∞·ªùng coi nh∆∞ ph·ª• √¢m ƒë·∫ßu
    for cl in ONSET_CLUSTERS:
        if syl.startswith(cl):
            return syl[len(cl):] or syl  # n·∫øu r·ªóng, tr·∫£ v·ªÅ ch√≠nh n√≥
    # n·∫øu b·∫Øt ƒë·∫ßu b·∫±ng ph·ª• √¢m ƒë∆°n -> b·ªè 1 k√Ω t·ª±
    if syl and syl[0] in CONSONANTS:
        syl = syl[1:]
    return syl or syllable  # fallback

def split_phrase(phrase: str) -> Tuple[str, str]:
    parts = " ".join(phrase.strip().lower().split()).split()
    if len(parts) != 2:
        return ("","")
    return parts[0], parts[1]

def rhyme_match(prev_phrase: Optional[str], next_phrase: str) -> bool:
    """L∆∞·ª£t sau ph·∫£i b·∫Øt ƒë·∫ßu b·∫±ng t·ª´ 1 c√≥ 'v·∫ßn' = v·∫ßn c·ªßa t·ª´ 2 ·ªü c·ª•m tr∆∞·ªõc."""
    if not prev_phrase:
        return True  # l∆∞·ª£t ƒë·∫ßu t·ª± do
    p1, p2 = split_phrase(prev_phrase)
    n1, n2 = split_phrase(next_phrase)
    if not (p2 and n1):
        return False
    return rhyme_key(p2) == rhyme_key(n1)

# ================== TR·∫†NG TH√ÅI TR·∫¨N ==================
@dataclass
class Match:
    chat_id: int
    lobby_open: bool = False
    joined: List[int] = field(default_factory=list)
    active: bool = False
    turn_idx: int = 0
    current_player: Optional[int] = None
    current_phrase: Optional[str] = None  # c·ª•m h·ª£p l·ªá tr∆∞·ªõc ƒë√≥

    # tasks
    auto_begin_task: Optional[asyncio.Task] = None
    half_task: Optional[asyncio.Task] = None
    timeout_task: Optional[asyncio.Task] = None

    used_phrases: Set[str] = field(default_factory=set)

    # Ch·∫ø ƒë·ªô 1 ng∆∞·ªùi
    solo_mode: bool = False
    solo_warn_count: int = 0  # s·ªë l·∫ßn ƒë√£ ‚Äúnh·∫Øc‚Äù ·ªü l∆∞·ª£t hi·ªán t·∫°i

    def cancel_turn_tasks(self):
        for t in (self.half_task, self.timeout_task):
            if t and not t.done():
                t.cancel()
        self.half_task = None
        self.timeout_task = None

    def cancel_auto_begin(self):
        if self.auto_begin_task and not self.auto_begin_task.done():
            self.auto_begin_task.cancel()
        self.auto_begin_task = None

matches: Dict[int, Match] = {}

# ================== TI·ªÜN √çCH ==================
async def mention_user(context: ContextTypes.DEFAULT_TYPE, chat_id: int, user_id: int) -> str:
    try:
        member = await context.bot.get_chat_member(chat_id, user_id)
        name = member.user.first_name or ""
        return f"[{name}](tg://user?id={user_id})"
    except Exception:
        return f"user_{user_id}"

def pick_next_idx(match: Match):
    if not match.joined:
        return
    match.turn_idx %= len(match.joined)
    match.current_player = match.joined[match.turn_idx]

def random_bot_phrase(match: Match) -> Optional[str]:
    """Bot ch·ªçn 1 c·ª•m ch∆∞a d√πng th·ªèa v·∫ßn."""
    # Ng∆∞·ªùi ch∆°i v·ª´a n√≥i -> l·∫•y v·∫ßn t·ª´ 2:
    if not match.current_phrase:
        # l∆∞·ª£t ƒë·∫ßu solo: bot nh·∫£ ng·∫´u nhi√™n
        candidates = list(DICT - match.used_phrases)
        return random.choice(candidates) if candidates else None
    _, prev_last = split_phrase(match.current_phrase)
    need_key = rhyme_key(prev_last)
    # c·∫ßn c·ª•m c√≥ t·ª´ 1 tr√πng v·∫ßn
    candidates = [p for p in DICT - match.used_phrases if rhyme_key(split_phrase(p)[0]) == need_key]
    return random.choice(candidates) if candidates else None

async def schedule_turn_timers(update: Update, context: ContextTypes.DEFAULT_TYPE, match: Match):
    """ƒê·∫∑t nh·∫Øc 30s v√† lo·∫°i sau 60s cho ng∆∞·ªùi ƒëang t·ªõi l∆∞·ª£t (ch·ªâ √°p cho ng∆∞·ªùi ch∆°i, kh√¥ng √°p cho bot)."""
    match.cancel_turn_tasks()

    async def half_warn():
        try:
            await asyncio.sleep(HALFTIME_SECONDS)
            if match.active:
                who = await mention_user(context, match.chat_id, match.current_player)
                msg = random.choice(HALF_WARNINGS)
                await context.bot.send_message(
                    match.chat_id, f"‚è≥ {who} ‚Äî {msg}", parse_mode=ParseMode.MARKDOWN
                )
        except asyncio.CancelledError:
            pass

    async def timeout_kick():
        try:
            await asyncio.sleep(ROUND_SECONDS)
            if not match.active:
                return
            who = match.current_player
            who_m = await mention_user(context, match.chat_id, who)
            await context.bot.send_message(match.chat_id, f"‚ùå {who_m} ‚Äî {TIMEOUT_MSG}", parse_mode=ParseMode.MARKDOWN)

            # SOLO: h·∫øt gi·ªù -> thua, k·∫øt th√∫c
            if match.solo_mode:
                match.active = False
                match.cancel_turn_tasks()
                await context.bot.send_message(match.chat_id, "üèÅ V√°n solo k·∫øt th√∫c. Bot th·∫Øng ü§ñ")
                return

            # MULTI: lo·∫°i player, chuy·ªÉn l∆∞·ª£t/trao c√∫p n·∫øu c√≤n 1
            if who in match.joined:
                idx = match.joined.index(who)
                match.joined.pop(idx)
                if idx <= match.turn_idx and match.turn_idx > 0:
                    match.turn_idx -= 1

            if len(match.joined) <= 1:
                if match.joined:
                    winner = await mention_user(context, match.chat_id, match.joined[0])
                    await context.bot.send_message(match.chat_id, f"üèÜ {winner} th·∫Øng cu·ªôc!", parse_mode=ParseMode.MARKDOWN)
                match.active = False
                match.cancel_turn_tasks()
                return

            # chuy·ªÉn l∆∞·ª£t
            match.turn_idx = (match.turn_idx + 1) % len(match.joined)
            pick_next_idx(match)
            who2 = await mention_user(context, match.chat_id, match.current_player)
            await context.bot.send_message(
                match.chat_id,
                f"üü¢ {who2} ƒë·∫øn l∆∞·ª£t. G·ª≠i **c·ª•m 2 t·ª´** c√≥ nghƒ©a (ƒë√∫ng v·∫ßn v·ªõi c·ª•m tr∆∞·ªõc).",
                parse_mode=ParseMode.MARKDOWN,
            )
            await schedule_turn_timers(update, context, match)
        except asyncio.CancelledError:
            pass

    # ch·ªâ ƒë·∫∑t timer cho l∆∞·ª£t ng∆∞·ªùi ch∆°i (kh√¥ng ƒë·∫∑t khi t·ªõi l∆∞·ª£t ‚Äúbot ·∫£o‚Äù)
    if not match.solo_mode or (match.solo_mode and match.current_player is not None):
        loop = asyncio.get_running_loop()
        match.half_task = loop.create_task(half_warn())
        match.timeout_task = loop.create_task(timeout_kick())

# ================== HANDLERS ==================
async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "Ch√†o c·∫£ nh√†! /newgame ƒë·ªÉ m·ªü s·∫£nh, /join ƒë·ªÉ tham gia.\n"
        f"ƒê·ªß 2 ng∆∞·ªùi, bot ƒë·∫øm ng∆∞·ª£c {AUTO_BEGIN_SECONDS}s r·ªìi t·ª± b·∫Øt ƒë·∫ßu.\n"
        f"Lu·∫≠t: ƒë√∫ng 2 t·ª´, c√≥ trong t·ª´ ƒëi·ªÉn, v√† **ƒë·ªëi v·∫ßn** (t·ª´ 1 c·ªßa c·ª•m m·ªõi ph·∫£i c√πng v·∫ßn v·ªõi t·ª´ 2 c·ªßa c·ª•m tr∆∞·ªõc).\n"
        f"T·ª´ ƒëi·ªÉn hi·ªán c√≥: {len(DICT)} c·ª•m 2 t·ª´."
    )

async def cmd_reload(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global DICT
    DICT = load_dict(DICT_FILE)
    await update.message.reply_text(f"üîÅ ƒê√£ n·∫°p l·∫°i t·ª´ ƒëi·ªÉn: {len(DICT)} c·ª•m 2 t·ª´.")

async def cmd_ping(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("pong ‚úÖ")

async def cmd_newgame(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    m = matches.get(chat_id) or Match(chat_id)
    # reset
    m.lobby_open = True
    m.joined = []
    m.active = False
    m.turn_idx = 0
    m.current_player = None
    m.current_phrase = None
    m.used_phrases.clear()
    m.solo_mode = False
    m.solo_warn_count = 0
    m.cancel_turn_tasks()
    m.cancel_auto_begin()
    matches[chat_id] = m

    await update.message.reply_text(
        f"üéÆ S·∫£nh m·ªü! /join ƒë·ªÉ tham gia.\n"
        f"‚û°Ô∏è Khi **ƒë·ªß 2 ng∆∞·ªùi**, bot s·∫Ω ƒë·∫øm ng∆∞·ª£c {AUTO_BEGIN_SECONDS}s r·ªìi t·ª± b·∫Øt ƒë·∫ßu."
    )

async def cmd_join(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    user_id = update.effective_user.id
    m = matches.get(chat_id)
    if not m or not m.lobby_open:
        await update.message.reply_text("Ch∆∞a /newgame m√† nh·∫≠p l·ªë n√® üòõ")
        return
    if user_id in m.joined:
        await update.message.reply_text("B·∫°n ƒë√£ tham gia!")
        return
    m.joined.append(user_id)
    who = await mention_user(context, chat_id, user_id)
    await update.message.reply_text(f"‚ûï {who} ƒë√£ tham gia!", parse_mode=ParseMode.MARKDOWN)

    # Khi v·ª´a ƒë·ªß 2 ng∆∞·ªùi ‚Üí b·∫Øt ƒë·∫ßu ƒë·∫øm ng∆∞·ª£c 60s (d√π sau ƒë√≥ c√≥ th√™m ng∆∞·ªùi v·∫´n START ƒë√∫ng l·ªãch)
    if len(m.joined) == 2 and m.auto_begin_task is None:
        async def auto_begin():
            try:
                await asyncio.sleep(AUTO_BEGIN_SECONDS)
                if m.lobby_open and not m.active and len(m.joined) >= 2:
                    await force_begin(update, context, m)
            except asyncio.CancelledError:
                pass
        loop = asyncio.get_running_loop()
        m.auto_begin_task = loop.create_task(auto_begin())
        await context.bot.send_message(chat_id, f"‚è≥ ƒê·ªß 2 ng∆∞·ªùi r·ªìi. {AUTO_BEGIN_SECONDS}s n·ªØa b·∫Øt ƒë·∫ßu t·ª± ƒë·ªông!")

async def cmd_begin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    m = matches.get(chat_id)
    if not m:
        await update.message.reply_text("Ch∆∞a /newgame k√¨a.")
        return
    await force_begin(update, context, m)

async def force_begin(update: Update, context: ContextTypes.DEFAULT_TYPE, m: Match):
    if m.active:
        return
    m.lobby_open = False
    m.cancel_auto_begin()

    if len(m.joined) == 0:
        await context.bot.send_message(m.chat_id, "Kh√¥ng c√≥ ai tham gia n√™n hu·ª∑ v√°n.")
        return

    if len(m.joined) == 1:
        # ===== SOLO MODE =====
        m.solo_mode = True
        m.solo_warn_count = 0
        m.active = True
        m.turn_idx = 0
        m.current_player = m.joined[0]
        m.current_phrase = None
        await context.bot.send_message(
            m.chat_id,
            "ü§ñ Ch·ªâ c√≥ 1 ng∆∞·ªùi tham gia ‚Üí ch∆°i SOLO v·ªõi bot.\n"
            "üìò Lu·∫≠t: ƒë√∫ng 2 t·ª´ ‚Ä¢ c√≥ trong t·ª´ ƒëi·ªÉn ‚Ä¢ **ƒë·ªëi v·∫ßn** (t·ª´ 1 c·ªßa c·ª•m m·ªõi ph·∫£i c√πng v·∫ßn v·ªõi t·ª´ 2 c·ªßa c·ª•m tr∆∞·ªõc).\n"
            "Sai s·∫Ω ƒë∆∞·ª£c nh·∫Øc t·ªëi ƒëa 3 l·∫ßn.",
        )
        who = await mention_user(context, m.chat_id, m.current_player)
        await context.bot.send_message(
            m.chat_id,
            f"üëâ {who} ƒëi tr∆∞·ªõc. G·ª≠i **c·ª•m 2 t·ª´** b·∫•t k·ª≥ (l∆∞·ª£t ƒë·∫ßu t·ª± do).",
            parse_mode=ParseMode.MARKDOWN,
        )
        await schedule_turn_timers(update, context, m)
        return

    # ===== MULTIPLAYER =====
    m.solo_mode = False
    m.active = True
    random.shuffle(m.joined)
    m.turn_idx = random.randrange(len(m.joined))
    m.current_player = m.joined[m.turn_idx]
    m.current_phrase = None

    await context.bot.send_message(
        m.chat_id,
        "üöÄ B·∫Øt ƒë·∫ßu (multiplayer)! Sai lu·∫≠t ho·∫∑c h·∫øt gi·ªù s·∫Ω b·ªã lo·∫°i.\n"
        "üìò Lu·∫≠t: ƒë√∫ng 2 t·ª´ ‚Ä¢ c√≥ trong t·ª´ ƒëi·ªÉn ‚Ä¢ **ƒë·ªëi v·∫ßn** (t·ª´ 1 c·ªßa c·ª•m m·ªõi ph·∫£i c√πng v·∫ßn v·ªõi t·ª´ 2 c·ªßa c·ª•m tr∆∞·ªõc).",
    )
    who = await mention_user(context, m.chat_id, m.current_player)
    await context.bot.send_message(
        m.chat_id,
        f"üëâ {who} ƒëi tr∆∞·ªõc. G·ª≠i **c·ª•m 2 t·ª´** b·∫•t k·ª≥ (l∆∞·ª£t ƒë·∫ßu t·ª± do).",
        parse_mode=ParseMode.MARKDOWN,
    )
    await schedule_turn_timers(update, context, m)

async def cmd_stop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    m = matches.get(chat_id)
    if not m:
        await update.message.reply_text("Kh√¥ng c√≥ v√°n n√†o.")
        return
    m.lobby_open = False
    m.active = False
    m.cancel_turn_tasks()
    m.cancel_auto_begin()
    await update.message.reply_text("‚õî ƒê√£ d·ª´ng v√°n hi·ªán t·∫°i.")

# ================== NH·∫¨N C√ÇU TR·∫¢ L·ªúI ==================
async def on_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.message.text:
        return
    chat_id = update.effective_chat.id
    user_id = update.effective_user.id
    text = " ".join(update.message.text.strip().lower().split())

    m = matches.get(chat_id)
    if not m or not m.active:
        return  # b·ªè qua khi kh√¥ng ch∆°i

    # ch·ªâ x√©t tin c·ªßa ng∆∞·ªùi ƒëang t·ªõi l∆∞·ª£t (multiplayer) ho·∫∑c c·ªßa ng∆∞·ªùi ch∆°i (solo)
    if user_id != m.current_player:
        return

    # 1) ƒë√∫ng 2 t·ª´, c√≥ trong t·ª´ ƒëi·ªÉn, ch∆∞a d√πng
    basic_ok = is_two_word_phrase_in_dict(text) and (text not in m.used_phrases)
    # 2) ƒë√∫ng lu·∫≠t v·∫ßn (tr·ª´ l∆∞·ª£t ƒë·∫ßu)
    rhyme_ok = rhyme_match(m.current_phrase, text)

    if not (basic_ok and rhyme_ok):
        if m.solo_mode:
            # SOLO: nh·∫Øc t·ªëi ƒëa 3 l·∫ßn, kh√¥ng lo·∫°i ngay
            if m.solo_warn_count < 3:
                hint = SOLO_HINTS[m.solo_warn_count] if m.solo_warn_count < len(SOLO_HINTS) else SOLO_HINTS[-1]
                m.solo_warn_count += 1
                await update.message.reply_text(f"‚ö†Ô∏è {hint}")
                return
            else:
                # qu√° 3 nh·∫Øc -> thua
                await update.message.reply_text("‚ùå Sai li√™n ti·∫øp. Bot th·∫Øng ü§ñ")
                m.active = False
                m.cancel_turn_tasks()
                return
        else:
            # MULTI: lo·∫°i ngay
            msg = random.choice(WRONG_ANSWERS)
            await update.message.reply_text(f"‚ùå {msg}")
            idx = m.joined.index(user_id)
            m.joined.pop(idx)
            if idx <= m.turn_idx and m.turn_idx > 0:
                m.turn_idx -= 1
            if len(m.joined) <= 1:
                if m.joined:
                    winner = await mention_user(context, chat_id, m.joined[0])
                    await context.bot.send_message(chat_id, f"üèÜ {winner} th·∫Øng cu·ªôc!", parse_mode=ParseMode.MARKDOWN)
                m.active = False
                m.cancel_turn_tasks()
                return
            # chuy·ªÉn l∆∞·ª£t
            m.turn_idx = (m.turn_idx + 1) % len(m.joined)
            m.current_player = m.joined[m.turn_idx]
            who2 = await mention_user(context, chat_id, m.current_player)
            await context.bot.send_message(
                chat_id, f"üü¢ {who2} ƒë·∫øn l∆∞·ª£t. G·ª≠i **c·ª•m 2 t·ª´** ƒë√∫ng v·∫ßn v·ªõi c·ª•m tr∆∞·ªõc.",
                parse_mode=ParseMode.MARKDOWN
            )
            await schedule_turn_timers(update, context, m)
            return

    # ===== H·ª¢P L·ªÜ =====
    m.used_phrases.add(text)
    m.current_phrase = text

    if m.solo_mode:
        # Reset b·ªô ƒë·∫øm c·∫£nh b√°o cho l∆∞·ª£t k·∫ø
        m.solo_warn_count = 0
        await update.message.reply_text("‚úÖ H·ª£p l·ªá. T·ªõi l∆∞·ª£t bot ü§ñ")
        # Hu·ª∑ timer v√¨ bot tr·∫£ ngay
        m.cancel_turn_tasks()

        bot_pick = random_bot_phrase(m)
        if not bot_pick:
            await context.bot.send_message(chat_id, "ü§ñ Bot h·∫øt ch·ªØ r·ªìi‚Ä¶ B·∫°n th·∫Øng! üèÜ")
            m.active = False
            return

        # Ki·ªÉm tra bot c√≥ tu√¢n lu·∫≠t v·∫ßn kh√¥ng (ph·∫£i ƒë√∫ng theo c·ª•m c·ªßa b·∫°n v·ª´a n√≥i)
        if not rhyme_match(m.current_phrase, bot_pick):
            # n·∫øu hi·∫øm khi kh√¥ng t√¨m ƒë∆∞·ª£c c·ª•m h·ª£p v·∫ßn: bot ch·ªãu thua
            await context.bot.send_message(chat_id, "ü§ñ H·∫øt ch·ªØ h·ª£p v·∫ßn‚Ä¶ B·∫°n th·∫Øng! üèÜ")
            m.active = False
            return

        m.used_phrases.add(bot_pick)
        m.current_phrase = bot_pick
        await context.bot.send_message(chat_id, f"ü§ñ Bot: **{bot_pick}**", parse_mode=ParseMode.MARKDOWN)

        # Tr·∫£ l∆∞·ª£t l·∫°i cho ng∆∞·ªùi ch∆°i + ƒë·∫∑t l·∫°i ƒë·ªìng h·ªì
        await context.bot.send_message(chat_id, "üëâ T·ªõi l∆∞·ª£t b·∫°n. G·ª≠i **c·ª•m 2 t·ª´** ƒë√∫ng v·∫ßn.")
        await schedule_turn_timers(update, context, m)
        return

    # MULTIPLAYER: chuy·ªÉn l∆∞·ª£t b√¨nh th∆∞·ªùng
    await update.message.reply_text("‚úÖ H·ª£p l·ªá. T·ªõi l∆∞·ª£t k·∫ø ti·∫øp!")
    m.turn_idx = (m.turn_idx + 1) % len(m.joined)
    m.current_player = m.joined[m.turn_idx]
    who2 = await mention_user(context, chat_id, m.current_player)
    await context.bot.send_message(
        chat_id, f"üü¢ {who2} ƒë·∫øn l∆∞·ª£t. G·ª≠i **c·ª•m 2 t·ª´** ƒë√∫ng v·∫ßn v·ªõi c·ª•m tr∆∞·ªõc.",
        parse_mode=ParseMode.MARKDOWN
    )
    await schedule_turn_timers(update, context, m)

# ================== T·∫†O APP ==================
def build_app() -> Application:
    token = os.getenv("TELEGRAM_TOKEN", "").strip()
    if not token:
        raise RuntimeError("Missing TELEGRAM_TOKEN")
    app = ApplicationBuilder().token(token).build()
    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CommandHandler("ping", cmd_ping))
    app.add_handler(CommandHandler("reload", cmd_reload))
    app.add_handler(CommandHandler("newgame", cmd_newgame))
    app.add_handler(CommandHandler("join", cmd_join))
    app.add_handler(CommandHandler("begin", cmd_begin))
    app.add_handler(CommandHandler("stop", cmd_stop))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, on_text))
    return app
